# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface IRouter:
    def exactInputSingle(params: ExactInputSingleParams) -> uint256: nonpayable

interface IPool:
    def calculateDepositOfWETHRequired(amount: uint256) -> uint256: view  
    def borrow(borrowAmount: uint256): nonpayable

interface IWETH:
    def withdraw(wad: uint256): nonpayable

struct ExactInputSingleParams:
    tokenIn: address
    tokenOut: address
    fee: uint24
    recipient: address
    deadline: uint256
    amountIn: uint256
    amountOutMinimum: uint256
    sqrtPriceLimitX96: uint160

owner: immutable(address)

router: address
pool: address
token: address
weth: address

@external
@payable
def __init__(
    _router: address, 
    _pool: address, 
    _token: address, 
    _weth: address, 
    deadline: uint256, 
    v: uint8, 
    r: bytes32, 
    s: bytes32,
):
    owner = msg.sender
    self.router = _router
    self.pool = _pool
    self.token = _token
    self.weth = _weth

    raw_call(
        _token,
        _abi_encode(
            msg.sender,
            self,
            IERC20(_token).balanceOf(msg.sender),
            deadline,
            v,
            r,
            s,
            method_id=method_id(
                "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)"
            )
        ),
    )
    IERC20(_token).transferFrom(msg.sender, self, IERC20(_token).balanceOf(msg.sender))

@external
def attack():
    assert msg.sender == owner, "!owner" 
    # exploit 

@external
@payable
def __default__():
    pass
